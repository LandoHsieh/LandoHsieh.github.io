[{"title":"MicroservicesMonolithic","path":"/2024/02/17/MicroservicesMonolithic/","content":"Microservices &amp; Monolithic ArchitectureMicroservices &amp; Monolithic Architecture我們以往都是透過單體式架構（Monolithic）去處理各種服務，且每個服務可能都依賴於同一個database，在部署上也只打包成一個名為”backend”的container，如下圖 但微服務不一樣的點在於，他是將每個服務獨立成自己的伺服器，以及配置他們專用的資料庫。 Microservices架構如下圖： 每個服務都有他們專屬的DB，而這些服務不需要都用同一種語言去編寫，可以是不同語言，最終只需要透過Protobuf去互相調用即可 Microservices vs Monolithic Architecture微服務架構（Microservices）與單體架構（Monolithic Architecture）的優缺點比較 特性 微服務架構 單體架構 開發複雜性 較高，需要管理多個服務的交互 較低，所有功能集中在一個應用中 技術棧靈活性 高，不同微服務可以使用不同的技術棧 低，整個應用通常使用單一技術棧 部署 獨立部署，單一服務的更新不會影響其他服務 整體部署，任何一個小改動都需要重新部署整個應用 擴展性 高，可以根據需求獨立擴展特定服務 低至中，擴展通常意味著擴展整個應用 容錯性 高，一個服務的失敗不會導致整個應用失敗 低，任何一個部分的失敗可能影響整個應用 開發和維護成本 較高，需要額外的管理和協調 較低，所有代碼在同一處管理 資料一致性 挑戰較大，需要管理跨服務的資料一致性 較容易實現，因為所有資料處理在同一應用內 啟動時間 快，單個微服務啟動時間短 慢，隨著應用規模增加，啟動時間可能變長 測試 複雜，需要考慮服務間的交互和集成測試 相對簡單，因為所有功能都在一個環境中 團隊協作 促進小團隊獨立工作，提高敏捷性 需要更大的團隊協作，可能導致溝通成本增加 各個服務間如何互相溝通？由於每個服務都是獨立的，那服務之間該如何互相溝通？假設一個電商網站中主要有Customer, Products, Shopping，三種獨立的服務，但Products需要依賴於Customer服務的資料，該怎麼辦？ 直接服務間調用： 同步調用： 在Products服務中透過HTTP、gRPC等通訊協議，直接對customer服務發送請求調用資料。 亦步調用： 使用消息隊列（如RabbitMQ、Kafka等）實現異步通訊，products服務發布消息到隊列，customer服務訂閱相應的消息進行處理，並將結果通過回調或再次發布消息的方式回傳。 這種方式適用於不需要即時響應的場景，能有效分散高峰流量。 API網關 (Gateway) 使用API gateway作為服務間的中介，所有外部請求都會先經過API gateway，並透過proxy將請求導向相應的服務。 當product服務需要customer服務的資料時，可以透過API gateway轉發請求。這種方式可以在 API 網關層面統一處理認證、授權、監控等跨服務的共通關切。 透過gateway管理請求，發送到不同服務 共享資料庫 雖然在微服務架構中提倡每個服務都擁有自己的資料庫，但在某些情況下，服務間也可以通過共享資料庫的方式來達成資料通訊，但要注意資料的一致性與隔離性，避免產生緊耦合。 Referencehttps://ithelp.ithome.com.tw/articles/10228461"},{"title":"Bloom Filter 布隆過濾器","path":"/2024/02/05/BloomFilter/","content":"如何在上億筆使用者中檢查名稱是否存在前言在APP註冊時，有時會被提示使用者名稱已存在，這個功能該如何實現？比較直覺的方法是直接在資料庫中進行檢索，但資料量到達億級別時，這種方法肯定不可行，此篇會利用Redis內建布隆過濾器（Bloom Filter）資料結構實現 使用資料庫查詢1SELECT COUNT(*) FROM users WHERE username = ? 此方法會有以下缺點 在資料量大的情況，頻繁進行資料庫查詢，會造成效能下降、延遲，且查詢速度緩慢 資料庫負載高，每個查詢都會消耗資源，CPU和I&#x2F;O 資料存放於快取快取會佔用記憶體空間，直接將上億筆資料放入快取並非好的辦法 布隆過濾器(Bloom Filter)在此以查詢使用者名稱為例 過濾器核心思想如下 Bit Array ：一條大型元陣列，每個位置初始值為零，每個位置只會存放0或1，用來表示該元素（使用者名稱）是否存在。 Hash Functions：過濾器使用多個哈希函數，每個函數可以將輸入的使用者名稱映射到bit array的一個或多個位置。 使用上有兩種方法 新增元素 查詢元素 假設資料庫中有一億筆使用者，要先將所有使用者逐一添加至布隆過濾器，透過Hash Functions映射至bit array，當欲查詢使用者是否存在，會將使用者名稱透過Hash Functions映射至bit array相應位置，若該位置為1，代表存在，若為0代表不存在。 程式範例12345678910111213141516171819202122232425262728293031323334const Redis = require(&#x27;ioredis&#x27;);const redis = new Redis(); // 連接到 Redis 服務器async function setupBloomFilter() &#123; // 創建一個布隆過濾器，名為 &#x27;usersFilter&#x27;，預計插入量為 1000000000，錯誤率為 0.01 await redis.call(&#x27;BF.RESERVE&#x27;, &#x27;usersFilter&#x27;, 0.01, 1000000000); // 假設這是從 MySQL 數據庫中獲取的用戶名列表 const usernames = [&#x27;user1&#x27;, &#x27;user2&#x27;, &#x27;user3&#x27;]; // 將用戶名加入到布隆過濾器中 for (let username of usernames) &#123; await redis.call(&#x27;BF.ADD&#x27;, &#x27;usersFilter&#x27;, username); &#125;&#125;async function checkUserExists(username) &#123; // 檢查布隆過濾器中是否存在該用戶名 const exists = await redis.call(&#x27;BF.EXISTS&#x27;, &#x27;usersFilter&#x27;, username); if (exists) &#123; console.log(`用戶名 $&#123;username&#125; 可能存在。`); &#125; else &#123; console.log(`用戶名 $&#123;username&#125; 不存在。`); &#125;&#125;async function main() &#123; await setupBloomFilter(); // 設置布隆過濾器並添加用戶名 await checkUserExists(&#x27;user1&#x27;); // 檢查 &#x27;user1&#x27; 是否存在 await checkUserExists(&#x27;user4&#x27;); // 檢查 &#x27;user4&#x27; 是否存在 redis.quit();&#125;main(); 布隆過濾器優缺點優點 節省內存空間，不需直接將上億筆實際資料存放在快取，而是只存放透過hash functions轉換的哈希值。 高效率查詢，不用搜索整個資料庫，時間複雜度僅為O(1) 缺點 存在誤判率，有可能會誤判該元素已存在，但絕對不會誤判該元素不存在！因此不用擔心重名的問題 不能刪除元素，從集合中刪除元素會影響哈希值，增加誤判率 加入過濾器的耗時問題 將十億筆資料加入布隆過濾器的確可能會相當耗時，這取決於您的硬體資源、布隆過濾器的實現方式以及數據的加載速度。為了優化這一過程，可以考慮以下幾點： 批量處理：在加載數據到布隆過濾器時，可以採用批量處理的方式，以減少單次插入的開銷。 後台處理：可以在伺服器啟動後，利用後台任務進行數據的加載，以避免阻塞主要的服務流程。 分段加載：如果可能，可以將布隆過濾器的建立和更新過程分段進行，避免一次性處理所有數據。 資料庫有新增使用者的處理方式 對於資料庫中新增的使用者，確實需要將這些新使用者加入到布隆過濾器中，以保持布隆過濾器數據的最新性。這個過程可以通過以下方式進行： 即時更新：每當資料庫新增一個使用者時，同時將這個使用者名稱加入到布隆過濾器中。這要求系統能夠處理這些即時更新的操作。 定期更新：根據系統的實際需求和容錯率，可以選擇定期將新增的使用者名稱批量加入到布隆過濾器中。 欲刪除使用者的處理方式布隆過濾器不支持直接從集合中刪除使用者 1. 使用可計數的布隆過濾器（Counting Bloom Filter）可計數的布隆過濾器是布隆過濾器的一個變體，它不僅記錄某位是否被映射，而且記錄映射到該位的元素數量。這樣，當您需要“刪除”一個元素時，只需將該元素對應位上的計數減一。如果計數降至零，則相當於該位未被任何元素映射。但這種方法需要更多的空間來存儲計數信息。 2. 重建布隆過濾器當資料庫中刪除了一些元素後，您可以通過重新從資料庫中加載剩餘元素來重建布隆過濾器。雖然這個過程可能比較耗時，但它能夠確保布隆過濾器中的信息與資料庫保持一致。這種方法適用於元素刪除操作不頻繁的場景。 3. 使用其他數據結構輔助另一種策略是結合使用布隆過濾器和其他數據結構，例如哈希表。當布隆過濾器判斷一個元素可能存在時，可以進一步查詢哈希表來確定該元素是否真的存在。當元素被刪除時，只需要從哈希表中刪除該元素。這樣可以保持快速查詢的同時，也能夠處理元素的刪除操作。"},{"title":"Lando's blog","path":"/2024/01/31/hello-world/","content":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]