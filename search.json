[{"title":"ECDH加密搭配JWT提升安全性","path":"/2024/08/05/JWT-ECDH/","content":"前言一般生成 JWT 時，都是透過設定好的固定字串當作 JWT 的密鑰（Secret key），然後再將 JWT 傳送到後端，並用相同的 Secret key 去做驗證，但這樣的做法安全性相對較低，如果固定的 Secret Key 被洩漏，攻擊者可以偽造 JWT，並且無法防止重放攻擊。 當使用 JWT（JSON Web Token）搭配 ECDH（橢圓曲線 Diffie-Hellman）密鑰交換來提升安全性時，主要目的是利用 ECDH 生成的共享秘密密鑰來簽名和驗證 JWT。這樣可以確保 JWT 的完整性和來源的可信性，並且在通信過程中不會暴露實際的簽名密鑰。 此篇將探討如何使用 ECDH 橢圓曲線進行密鑰交換生成 Secret Key 提升 JWT 的安全性。 使用情境假設有一個 IoT 設備（Device）需要對雲端服務（Server）發送 API 請求，請求中需要包含生成的 JTW，透過 JWT 驗證請求是否有效。以下是一個具體的使用情境： Device 初始化：第一次啟用 Device 時要做的事 Device 中生成一對 ECC 密鑰對（dPub和dPri），並將 dPub 傳送到後端 DB 儲存。（每個 Device 都有一個儲存自己 dPub 的欄位） Server 中生成一對 ECC 密鑰對（sPub和sPri），將 sPub 傳送給 Device 中儲存（亦可直接編譯在 Device 內） 這樣 Server 端就會有 dPub, sPub, sPri 三個，而 Device 內就會有 dPub, dPri, sPub 三個 當 Device 要對 Server 發送 API 請求時 Device 透過dPri跟sPub生成共享密鑰 (Secret Key) Device 用這個 Secret key 跟 Payload 簽名 JWT (payload 中包含 Device UUID) Device 將簽名好的 JWT 發送到 Server Server 收到 JWT 後，將 sPri與dPub生成共享密鑰 (Secret Key) Server 用這組密鑰驗證 JWT 是否有效，有效則處理 request 具體步驟與程式碼範例下面就用 ASP.NET 來做個範例，用於生成和驗證使用 ECDH 密鑰交換的 JWT： 1. 生成密鑰對123456789private static ECDsa _ecdsa;private static ECDsa _ecdsaByDevice;static JwtValidatorController()&#123; // 當Controller第一次被使用時生成ECDsa密鑰 _ecdsa = ECDsa.Create(ECCurve.NamedCurves.nistP256); _ecdsaByDevice = ECDsa.Create(ECCurve.NamedCurves.nistP256);&#125; 2. 生成 Server 端和 Device 端的公私鑰對123456789101112131415161718192021222324252627282930313233343536[HttpGet(&quot;generateKeyByServer&quot;)]public IActionResult GenerateKeys()&#123; byte[] publicKey = _ecdsa.ExportSubjectPublicKeyInfo(); string publicKeyBase64 = Convert.ToBase64String(publicKey); byte[] privateKey = _ecdsa.ExportPkcs8PrivateKey(); string privateKeyBase64 = Convert.ToBase64String(privateKey); var keys = new &#123; PublicKey = publicKeyBase64, PrivateKey = privateKeyBase64 &#125;; return Ok(keys);&#125;[HttpGet(&quot;generateKeyByDevice&quot;)]public IActionResult GenerateKeysByDevice()&#123; byte[] publicKey = _ecdsaByDevice.ExportSubjectPublicKeyInfo(); string publicKeyBase64 = Convert.ToBase64String(publicKey); byte[] privateKey = _ecdsaByDevice.ExportPkcs8PrivateKey(); string privateKeyBase64 = Convert.ToBase64String(privateKey); var keys = new &#123; PublicKey = publicKeyBase64, PrivateKey = privateKeyBase64 &#125;; return Ok(keys);&#125; 3. 創建 JWT123456789101112131415161718192021222324252627282930313233public class CreateJwtRequest&#123; public string ServerPublicKey &#123; get; set; &#125; public string DevciePrivateKey &#123; get; set; &#125;&#125;[HttpPost(&quot;create-jwt&quot;)]public IActionResult CreateJwt([FromBody] CreateJwtRequest request)&#123; var diffieHellmanA = ECDiffieHellman.Create(); diffieHellmanA.ImportSubjectPublicKeyInfo(Convert.FromBase64String(request.ServerPublicKey), out _); var diffieHellmanB = ECDiffieHellman.Create(); diffieHellmanB.ImportPkcs8PrivateKey(Convert.FromBase64String(request.DevciePrivateKey), out _); var derivedKey = diffieHellmanB.DeriveKeyMaterial(diffieHellmanA.PublicKey); var signingCredentials = new SigningCredentials(new SymmetricSecurityKey(derivedKey), SecurityAlgorithms.HmacSha256); var header = new JwtHeader(signingCredentials); var payload = new JwtPayload &#123; &#123; JwtRegisteredClaimNames.Sub, &quot;testuser&quot; &#125;, &#123; JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString() &#125;, &#123; &quot;exp&quot;, DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeSeconds() &#125; &#125;; var token = new JwtSecurityToken(header, payload); var tokenHandler = new JwtSecurityTokenHandler(); string jwt = tokenHandler.WriteToken(token); return Ok(new &#123; Token = jwt &#125;);&#125; 4. 驗證 JWT1234567891011121314151617181920212223242526272829303132333435363738394041public class VaildateJwtKey&#123; public string Jwt &#123; get; set; &#125; public string DevicePublicKey &#123; get; set; &#125; public string ServerPrivateKey &#123; get; set; &#125;&#125;[HttpPost(&quot;validate-jwt&quot;)]public IActionResult ValidateJwt([FromBody] VaildateJwtKey request)&#123; var tokenHandler = new JwtSecurityTokenHandler(); var jwtToken = tokenHandler.ReadJwtToken(request.Jwt); var diffieHellmanA = ECDiffieHellman.Create(); diffieHellmanA.ImportPkcs8PrivateKey(Convert.FromBase64String(request.ServerPrivateKey), out _); var diffieHellmanB = ECDiffieHellman.Create(); diffieHellmanB.ImportSubjectPublicKeyInfo(Convert.FromBase64String(request.DevicePublicKey), out _); var derivedKey = diffieHellmanA.DeriveKeyMaterial(diffieHellmanB.PublicKey); var validationParameters = new TokenValidationParameters &#123; ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, IssuerSigningKey = new SymmetricSecurityKey(derivedKey) &#125;; try &#123; var principal = tokenHandler.ValidateToken(request.Jwt, validationParameters, out var validatedToken); var claims = principal.Claims.Select(c =&gt; new &#123; c.Type, c.Value &#125;); return Ok(new &#123; Valid = true, Claims = claims &#125;); &#125; catch (Exception ex) &#123; return BadRequest(new &#123; Valid = false, Error = ex.Message &#125;); &#125;&#125; 這樣，你就可以使用 ECDH 密鑰交換來生成共享的秘密密鑰，並使用該密鑰來簽名和驗證 JWT，從而提升 JWT 的安全性。 ECDH 密鑰交換優缺點優點高安全性：◦ ECDH 密鑰交換協議確保只有通信雙方能生成相同的共享秘密密鑰，第三方無法獲取這個密鑰。◦ 每次通信都可以生成新的共享秘密密鑰，防止重放攻擊。 動態密鑰生成：◦ 每次通信都可以生成新的共享秘密密鑰，進一步提高安全性。 防篡改和偽造：◦ 由於密鑰交換過程中不傳輸私鑰，攻擊者無法偽造 JWT。 缺點實現複雜：◦ 需要實現 ECDH 密鑰交換協議，增加了實現的複雜性。◦ 需要管理公私鑰對，增加了開發和運維的負擔。 性能較低：◦ 生成和驗證 JWT 的過程中需要進行複雜的計算，性能較低。 總結使用 ECDH 密鑰交換來生成共享的秘密密鑰，並使用該秘密密鑰來簽名和驗證 JWT，具有以下優點： 提高安全性： ECDH 密鑰交換確保只有通信雙方能生成相同的共享秘密密鑰，第三方無法獲取這個密鑰。 使用共享的秘密密鑰來簽名和驗證 JWT，確保 JWT 的完整性和來源的可信性。 簡化密鑰管理： 雙方只需交換公鑰，無需共享私鑰，減少了密鑰管理的複雜性和風險。 動態密鑰生成： 每次通信都可以生成新的共享秘密密鑰，進一步提高安全性。","tags":["ASP.NET"]},{"title":"Flutter Riverpod 狀態管理工具","path":"/2024/07/24/Flutter-riverpod/","content":"什麼是 Riverpod？Riverpod 是由 Remi Rousselet 創建的一個強大且靈活的狀態管理解決方案。它旨在解決 Provider 包的一些限制，提供更好的可測試性、更多的靈活性和更少的全局狀態依賴。 安裝在你的 Flutter 項目中添加 flutter_riverpod 依賴項。 1234dependencies: flutter: sdk: flutter flutter_riverpod: ^1.0.0 然後運行以下命令來安裝依賴項： 1flutter pub get 基本用法1. 創建 ProviderProvider 是 Riverpod 中的核心概念，用於管理應用程序的狀態。以下是一個簡單的計數器 Provider： 123456import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateProviderfinal counterProvider = StateProvider&lt;int&gt;((ref) &#123; return 0;&#125;); 2. 使用 ProviderScopeProviderScope 是一個 Widget，用於提供一個狀態作用域，該作用域內的所有 Provider 都可以共享相同的狀態。通常將 ProviderScope 放在應用程序的根部。 123456789101112131415161718192021import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;void main() &#123; runApp( const ProviderScope( child: MyApp(), ), );&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), ); &#125;&#125; 3. 使用 ConsumerWidgetConsumerWidget 是一個 Widget，用於訪問和使用 Provider 的狀態。你可以在 build 方法中使用 ref.watch 來監聽 Provider 的狀態變化，並使用 ref.read 來更新狀態。 12345678910111213141516171819202122232425262728class HomePage extends ConsumerWidget &#123; @override Widget build(BuildContext context, WidgetRef ref) &#123; // 使用 Provider 來訪問狀態 final counter = ref.watch(counterProvider); return Scaffold( appBar: AppBar( title: Text(&#x27;Riverpod Example&#x27;), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(&#x27;Counter: $counter&#x27;), ElevatedButton( onPressed: () &#123; // 使用 Provider 來更新狀態 ref.read(counterProvider.state).state++; &#125;, child: Text(&#x27;Increment&#x27;), ), ], ), ), ); &#125;&#125; 進階用法1. 使用 StateNotifierProviderStateNotifierProvider 用於管理更複雜的狀態。你可以創建一個 StateNotifier 類來管理狀態，並使用 StateNotifierProvider 提供這個狀態。 12345678910111213import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateNotifier 類class CounterNotifier extends StateNotifier&lt;int&gt; &#123; CounterNotifier() : super(0); void increment() =&gt; state++;&#125;// 創建一個 StateNotifierProviderfinal counterNotifierProvider = StateNotifierProvider&lt;CounterNotifier, int&gt;((ref) &#123; return CounterNotifier();&#125;); 2. 使用 Provider 類型Riverpod 提供了多種 Provider 類型來管理不同的狀態： Provider：用於提供只讀的狀態。StateProvider：用於提供可變的狀態。FutureProvider：用於管理異步狀態。StreamProvider：用於管理流狀態。StateNotifierProvider：用於管理更複雜的狀態。 程式範例以下是一個完整的範例，展示如何使用 StateNotifierProvider 來管理計數器狀態： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateNotifier 類class CounterNotifier extends StateNotifier&lt;int&gt; &#123; CounterNotifier() : super(0); void increment() =&gt; state++;&#125;// 創建一個 StateNotifierProviderfinal counterNotifierProvider = StateNotifierProvider&lt;CounterNotifier, int&gt;((ref) &#123; return CounterNotifier();&#125;);void main() &#123; runApp( const ProviderScope( child: MyApp(), ), );&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), ); &#125;&#125;class HomePage extends ConsumerWidget &#123; @override Widget build(BuildContext context, WidgetRef ref) &#123; // 使用 Provider 來訪問狀態 final counter = ref.watch(counterNotifierProvider); return Scaffold( appBar: AppBar( title: Text(&#x27;Riverpod Example&#x27;), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(&#x27;Counter: $counter&#x27;), ElevatedButton( onPressed: () &#123; // 使用 Provider 來更新狀態 ref.read(counterNotifierProvider.notifier).increment(); &#125;, child: Text(&#x27;Increment&#x27;), ), ], ), ), ); &#125;&#125; 總結ProviderScope：提供一個狀態作用域，該作用域內的所有 Provider 都可以共享相同的狀態。Provider 類型：包括 Provider、StateProvider、FutureProvider、StreamProvider 和 StateNotifierProvider。","tags":["Flutter Package"]},{"title":"Dart中的const常量","path":"/2024/07/18/dart-const/","content":"什麼是 const在 Dart 和 Flutter 中，const關鍵字用於創建編譯時期常量。這意味著在編譯時期就確定了對象的值，並且在運行時期無法更改。 const 的優點1. 提升效能 使用 const 可以提升效能，因為常量對象在內存中只會創建一次，並且在多個地方重用。這減少了內存分配和垃圾回收的開銷。 2. 保證不可變性 const 保證對象在創建後無法更改，這有助於避免意外的狀態變更，並提高代碼的穩定性和可預測性。 使用 const 的注意事項1. 所有字段必須是 final 當你為一個類定義 const 構造函數時，該類中的所有字段必須是 final，因為 const 構造函數要求對象在編譯時期確定所有屬性。 123456789101112131415class MyButton extends StatelessWidget &#123; final String text; final VoidCallback onPressed; const MyButton(&#123; super.key, required this.text, required this.onPressed, &#125;); @override Widget build(BuildContext context) &#123; return const Placeholder(); &#125;&#125; 2. 嵌套的 const 如果一個 const 對象包含其他對象，這些對象也必須是 const。這樣可以確保整個對象樹在編譯時期都是常量。 12345const myList = [ const Text(&#x27;Item 1&#x27;), const Text(&#x27;Item 2&#x27;), const Text(&#x27;Item 3&#x27;),]; 3. 使用 const 構造函數 在 Flutter 中，許多 widget 可以使用 const 構造函數來創建不可變的 widget 樹。這有助於提高效能，因為常量 widget 不需要重新構建。 123456789101112@overrideWidget build(BuildContext context) &#123; return const Scaffold( appBar: AppBar( title: Text(&#x27;My App&#x27;), ), body: Center( child: Text(&#x27;Hello, World!&#x27;), ), );&#125; 4. 使用 const 關鍵字 在創建常量對象時，確保在構造函數前添加 const 關鍵字。這樣可以明確表示該對象是常量。 123456const myButton = MyButton( text: &#x27;Click Me&#x27;, onPressed: () &#123; print(&#x27;Button Pressed!&#x27;); &#125;,);","tags":["dart"]},{"title":"Future void vs void in Dart","path":"/2024/07/18/dart-future-void/","content":"Future vs void in Dart1. 概述在 Dart 中，Future&lt;void&gt; 和 void 都可以用來定義方法的返回類型，但它們有不同的用途和行為。理解這兩者的區別對於編寫清晰、可維護和正確的異步程式碼至關重要。 2. Future&lt;void&gt;定義Future&lt;void&gt; 表示一個異步操作，這個操作在完成時不會返回任何值。它允許調用者等待操作完成並進行錯誤處理。 使用情境當方法需要執行異步操作並且調用者需要等待操作完成時。當方法可能會拋出異步錯誤並且需要錯誤處理時。 範例1234567891011Future&lt;void&gt; fetchData() async &#123; // 模擬一個異步操作，例如網絡請求 await Future.delayed(Duration(seconds: 2)); print(&#x27;Data fetched&#x27;);&#125;void main() async &#123; print(&#x27;Fetching data...&#x27;); await fetchData(); print(&#x27;Data fetch complete&#x27;);&#125; 重點明確的異步操作：Future&lt;void&gt; 明確表示這是異步操作。等待異步操作完成：調用者可以使用 await 等待操作完成。錯誤處理：調用者可以使用 try-catch 進行錯誤處理。 3. void定義void 表示方法不會返回任何值。這通常用於同步方法，但也可以用於異步方法（不推薦）。 使用情境當方法是同步的並且不需要返回值時。當方法是異步的但調用者不需要等待操作完成（不推薦）。 範例1234567void printMessage() &#123; print(&#x27;Hello, World!&#x27;);&#125;void main() &#123; printMessage();&#125; 重點同步操作：通常用於同步方法。無法等待異步操作完成：如果用於異步方法，調用者無法等待操作完成，可能導致競態條件。 4. 比較 特性 Future&lt;void&gt; void 返回類型 異步操作，不返回值 同步操作，不返回值 等待操作完成 可以使用 await 等待操作完成 無法等待操作完成 錯誤處理 可以使用 try-catch 進行錯誤處理 只能處理同步錯誤 使用情境 當需要執行異步操作並等待完成時 當方法是同步且不需要返回值時 典型範例 網絡請求、文件操作等異步操作 打印消息、計算等同步操作 5. 總結Future&lt;void&gt;：適用於異步操作，允許調用者等待操作完成並進行錯誤處理。應該用於需要異步執行的任務。void：適用於同步操作，不允許調用者等待操作完成。應該用於不需要返回值的同步方法。","tags":["dart"]},{"title":"CAP定理-分散式系統","path":"/2024/03/25/CAP theorem/","content":"CAP主要是探討 資料分區 (Partition) 的問題，當為了分散流量處理而新增多個資料庫節點時，每個節點的資料勢必要保持一致，才不會導致有時使用者取得到的是最新資料，有時取得到舊資料，但世界上不存在100%穩定的網路，有時會因為延遲或斷線導致資料庫之間的資料不一致，這就是CAP主要探討的議題。 CAP定義CAP主要有以下三種條件 C 一致性 (Consistency)：使用者Always拿到最新的資料，所有分散式節點對同一份資料的讀取操作，都應該返回相同的值。 A 可用性 (Availability) : 使用者Always在有限時間內得到回應。 P 分區容錯性 (Partition tolerance) : 即使發生網路分區，系統也應該要能夠繼續運作。 CAP的選擇CAP定理告訴我們，在分散式系統中，不可能同時滿足ＣＡＰ三種條件，只能選擇其中兩種條件來滿足。 CA 一致性、可用性（最不考慮）不考慮CA是因為，若要滿足這兩個條件，必須確保各個節點的資料必須100%同步，且100％可用不出錯，這代表網路環境必須100%穩定才可實現，或是直接使用單一資料庫的架構（不必考慮資料庫間的網路問題），但這樣的做法就失去了CAP的意義，因此不考慮CA的組合。 CP 一致性、分區容錯性每個節點的讀寫都是最新的資料，也就是達成一致性，但又要在資料分區的狀況下讓系統正常運作，這意味著，必須犧牲掉可用性（Always取得回應），當資料分區時，我們沒辦法給予最新的資料，因此使用者的請求會直接失敗，沒有任何一個資料庫會片面地改變資料的狀態。 我們保證了資料的C（一致性），但犧牲了使用者總是能得到回應的A（可用性）。 AP 可用性、分區容錯性使用者Always得到回應，同時又要在資料分區狀況下讓系統正常運作，當使用者要新增資料到某個資料庫節點，但因為網路分區造成其他資料庫沒有即時同步，為了滿足Always得到回應，因此犧牲掉C (一致性) ，仍然將資料更新至該節點。 使用場合強一致性 (String Consistency)即為CP，對於一致性要求較高，可以容忍暫時不可用的應用，像是金融交易這類的，資料需要保持一致的場合。 最終一致性 (Eventually Consistency)即為AP，顧名思義就是“最後”才會保持一致，不必要求當下每個資料庫節點的資料就要立即一致，像是遇到網路暫時中斷或延遲，沒有即時同步資料到其他資料庫，還是可以讓使用者繼續存取資料得到回應（不是最新的資料也沒差），這種會應用在文章留言、影片觀看次數、社交媒體、內容轉發等場合。","tags":["分散式系統"]},{"title":"如何提升API安全性","path":"/2024/02/27/API-security/","content":"API作為資料通訊的大門，我們應該重視它的安全性，即便有些API可以很輕鬆地去進行調用，但不代表應該讓所有API都不受限制地被存取調用。 API可以做很多事，資料請求、處理敏感資訊、CRUD資料庫，甚至可以透過API控制電子設備，因此在APP開發上，針對API做嚴格的身份驗證及管理就會顯得格外重要。 Authentication &amp; Authorization當收到API請求時，通常會先進行 Authentication以及Authorization 身份驗證以及授權，成功授權才可以進行請求， Authentication(驗證）: 顧名思義就是驗證使用者的身份是否正確，可透過username, password等方式進行驗證，這些資訊可在使用者的請求資訊中取得。 Authorization(授權)：當身份驗證成功，就能對進行授權，回傳資料給使用者。 1. 透過JWT實現授權JWT (Json Web Token)，通常在使用者成功登入後（驗證帳號密碼），會透過JWT產生一組具有時效性的Token給使用者（可儲存於cookies或localStorage），之後使用者在操作一些功能時必須將token一並附上才可使用。 生成JWT 程式範例 123456789101112131415161718const jwt = require(&#x27;jsonwebtoken&#x27;);// 用戶資訊，可以是任何你想要儲存在 token 中的資訊const user = &#123; id: 1, // 假設的用戶 ID username: &quot;exampleUser&quot;, email: &quot;user@example.com&quot;&#125;;// 密鑰，用於簽名 JWT，應保持秘密const secretKey = &quot;yourSecretKey&quot;;// 生成 JWTconst token = jwt.sign(user, secretKey, &#123; expiresIn: &#x27;1h&#x27; // token 有效期，這裡設為 1 小時&#125;);console.log(token); 當使用者欲發送API請求，需要將登入後拿到的token一併附上，server會透過此token進行驗證，並給予授權。 驗證JWT 程式範例 1234567891011121314151617181920212223// 替換成你的密鑰const secretKey = &quot;yourSecretKey&quot;;// JWT 驗證 Middlewareconst verifyToken = (req, res, next) =&gt; &#123; // 從請求頭部取得 token const token = req.headers[&#x27;authorization&#x27;]; if (!token) &#123; return res.status(403).send(&#123; message: &quot;未提供 token!&quot; &#125;); &#125; try &#123; // 驗證 token const decoded = jwt.verify(token, secretKey); // 將用戶資訊附加到請求對象 req.user = decoded; next(); &#125; catch (error) &#123; // 如果驗證失敗，返回錯誤訊息 return res.status(401).send(&#123; message: &quot;無效的 token!&quot; &#125;); &#125;&#125;; 2. 細粒度存取控制Fine-Grained Access Control定義角色和權限定義每個角色可以做什麼事情，像是Admin可以進入控制台介面，User則不行。 RBAC (Role-Based Access Control)RBAC是一種基於角色的訪問控制機制，每個角色都被授予一些權限，根據用戶的角色來決定對系統資源的訪問權限。在這種模式下，訪問權限會被賦予角色，用戶會被指派到一個或多個角色，這樣就能獲得相應的訪問權限。 1234567891011121314151617181920212223242526272829303132333435363738// 假設的用戶資料和角色const users = [ &#123; id: 1, username: &#x27;Lando&#x27;, role: &#x27;admin&#x27; &#125;, &#123; id: 2, username: &#x27;Josh&#x27;, role: &#x27;user&#x27; &#125;];// 簡單的身份驗證中間件function authMiddleware(req, res, next) &#123; const user = users.find(u =&gt; u.username === req.headers.username); // 假設使用username進行簡單的&quot;身份驗證&quot; if (!user) &#123; return res.status(401).send(&#x27;Authentication failed&#x27;); &#125; req.user = user; next();&#125;// 已定義好的角色權限const rolesPermissions = &#123; admin: [&#x27;create&#x27;, &#x27;read&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;], user: [&#x27;read&#x27;]&#125;;// RBAC中間件function roleMiddleware(allowedRoles) &#123; return function(req, res, next) &#123; const userRole = req.user.role; const permissions = rolesPermissions[userRole] || []; const isAllowed = allowedRoles.some(role =&gt; permissions.includes(role)); if (!isAllowed) &#123; return res.status(403).send(&#x27;Access denied&#x27;); &#125; next(); &#125;;&#125;app.get(&#x27;/data&#x27;, authMiddleware, roleMiddleware([&#x27;read&#x27;]), (req, res) =&gt; &#123; res.send(&#x27;Some data accessible by users with read permission&#x27;);&#125;); ABAC (Attribute-Based Access Control)ABAC能夠提供基於多種條件的細粒度訪問控制，當需要根據用戶的具體屬性（年齡、位置、工作角色等）來細化訪問權限，通常會使用於更複雜或是需要極度安全性的場景，例如軍事系統、政府等。 3. API Gateway提升安全性你可以把API網關想像成所有API的前門，所有請求都必須先通過前門才碰得到後面的API，舉個例子，假如每個API都有一樣的身份驗證middleware，這樣只需要在API gateway加入身份驗證，如此一來所有請求都會先進行身份驗證後，再將請求轉發到相應的API route。 API網關有以下用途： 增加安全性：防止未經授權的請求、濫用，或是DDoS攻擊。 Rate Limiting &#x2F; Throttling：速率控制和節流，防止API過度使用，或是確保使用者之間的公平使用，可使用express-rate-limit套件或是其他平台的服務，例如AWS API Gateway, Google Apigee等。 12345678910111213141516const rateLimit = require(&#x27;express-rate-limit&#x27;);// 創建 rate limit 中間件const limiter = rateLimit(&#123; windowMs: 15 * 60 * 1000, // 15 分鐘的時間窗口 max: 100, // 在時間窗口內每個IP可以發起的最大請求數 standardHeaders: true, // 返回 rate limit 信息於 `RateLimit-*` headers legacyHeaders: false, // 禁用 `X-RateLimit-*` headers message: &#x27;請求過於頻繁，請在一段時間後再試。&#x27; // 當 rate limit 被觸發時返回的錯誤信息&#125;);// 使用這個中間件於你的應用中，例如// app.use(limiter);// 你也可以只對特定的路由使用這個中間件// app.use(&#x27;/api/&#x27;, limiter); 資料驗證：驗證傳入的資料是否符合格式標準，亦可預防SQL Injection等攻擊。 4. DOMPurify當我們設計一個Input的元件給客戶端做輸入時，也有機率遭受到攻擊，因為input可以被寫入程式碼，例如：&lt;script&gt;alert(false)&lt;/script&gt;，這時我們可以使用DOMPurify套件來清除輸入的資料，避免XSS攻擊。 安裝12345// 先執行命令進行安裝$ npm install dompurify// JS 檔案中 importimport * as DOMPurify from &#x27;dompurify&#x27;; 使用假如我們有一個input，取得使用者資訊 1&lt;input type=&quot;text&quot; id=&quot;userName&quot;&gt; 將資訊傳送給後端時先透過DOMPurify處理過 12const input = document.getElementById(&#x27;userName&#x27;);const userName = DOMPurify.sanitize(input.value); 這樣就可以清除程式碼的注入，多提升了一點安全性。 5. 透過SSL&#x2F;TLS加密傳輸資料到ZeroSSL網站為你的網域申請SSL憑證，申請成功會拿到certificate.crt以及private.key兩個憑證檔案，自行將其放入伺服器資料夾（我是放到 &#x2F;etc&#x2F;ssl 目錄底下 ），再透過nginx.conf設定SSL憑證路徑，保存後執行Nginx即可。 1234567891011121314server &#123; listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/your/certificate.crt; # Path to your fullchain.pem from CA ssl_certificate_key /path/to/your/private.key; # Path to your private key from CA # 指定TLS版本 ssl_protocols TLSv1.2 TLSv1.3; # 定義加密套件 ssl_ciphers &#x27;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256...&#x27;; # 其餘設定&#125; ssl_protocols : 指定TLS版本亦可提升安全性，在此指定1.2跟1.3版本的連線，因為這些是目前被認為是安全的協議版本，較舊的協議版本（如 SSL v2、SSL v3、TLS v1.0）因已知的安全漏洞而不建議使用。 ssl_ciphers : 這個指令用來定義哪些加密套件（cipher suites）被允許用於 SSL&#x2F;TLS 連線。加密套件定義了數據加密、驗證和消息完整性檢查的算法。 除了像SSL這種加密傳輸的方式以外，也有一些靜態加密的方法 bcrypt : 加密套件，在存入資料庫之前先對資料進加密。 MySQL : InnoDB表空間加密，在資料寫入磁碟前被加密，從磁碟讀取時解密。 MongoDB : 加密儲存引擎，也是在儲存資料之前先將其加密。 總結提升API的安全性除了能夠保障你的數位資產，同時也能夠保障用戶對你的信任，在開發API前不妨連同安全性也一起考慮進去，以防範各種網路威脅。"},{"title":"微服務 vs 單體式架構","path":"/2024/02/14/MicroservicesMonolithic/","content":"Microservices &amp; Monolithic Architecture前言我們以往都是透過單體式架構（Monolithic）去處理各種服務，且每個服務可能都依賴於同一個database，在部署上也只打包成一個名為”backend”的container，如下圖 但微服務不一樣的點在於，他是將每個服務獨立成自己的伺服器，以及配置他們專用的資料庫。 Microservices架構如下圖： 每個服務都有他們專屬的DB，而這些服務不需要都用同一種語言去編寫，可以是不同語言，最終只需要透過Protobuf去互相調用即可 Microservices vs Monolithic Architecture微服務架構（Microservices）與單體架構（Monolithic Architecture）的優缺點比較 特性 微服務架構 單體架構 開發複雜性 較高，需要管理多個服務的交互 較低，所有功能集中在一個應用中 技術棧靈活性 高，不同微服務可以使用不同的技術棧 低，整個應用通常使用單一技術棧 部署 獨立部署，單一服務的更新不會影響其他服務 整體部署，任何一個小改動都需要重新部署整個應用 擴展性 高，可以根據需求獨立擴展特定服務 低至中，擴展通常意味著擴展整個應用 容錯性 高，一個服務的失敗不會導致整個應用失敗 低，任何一個部分的失敗可能影響整個應用 開發和維護成本 較高，需要額外的管理和協調 較低，所有代碼在同一處管理 資料一致性 挑戰較大，需要管理跨服務的資料一致性 較容易實現，因為所有資料處理在同一應用內 啟動時間 快，單個微服務啟動時間短 慢，隨著應用規模增加，啟動時間可能變長 測試 複雜，需要考慮服務間的交互和集成測試 相對簡單，因為所有功能都在一個環境中 團隊協作 促進小團隊獨立工作，提高敏捷性 需要更大的團隊協作，可能導致溝通成本增加 各個服務間如何互相溝通？由於每個服務都是獨立的，那服務之間該如何互相溝通？假設一個電商網站中主要有Customer, Products, Shopping，三種獨立的服務，但Products需要依賴於Customer服務的資料，該怎麼辦？ 直接服務間調用： 同步調用： 在Products服務中透過HTTP、gRPC等通訊協議，直接對customer服務發送請求調用資料。 亦步調用： 使用消息隊列（如RabbitMQ、Kafka等）實現異步通訊，products服務發布消息到隊列，customer服務訂閱相應的消息進行處理，並將結果通過回調或再次發布消息的方式回傳。 這種方式適用於不需要即時響應的場景，能有效分散高峰流量。 API網關 (Gateway) 使用API gateway作為服務間的中介，所有外部請求都會先經過API gateway，並透過proxy將請求導向相應的服務。 當product服務需要customer服務的資料時，可以透過API gateway轉發請求。這種方式可以在 API 網關層面統一處理認證、授權、監控等跨服務的共通關切。 透過gateway管理請求，發送到不同服務 12345678910111213141516171819//API Gatewayconst express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)const proxy = require(&#x27;express-http-proxy&#x27;)const app = express()const PORT = 8000app.use(cors())app.use(express.json())app.use(&#x27;/customer&#x27;, proxy(&#x27;http://localhost:8001&#x27;))app.use(&#x27;/shopping&#x27;, proxy(&#x27;http://localhost:8003&#x27;))app.use(&#x27;/&#x27;, proxy(&#x27;http://localhost:8002&#x27;)) // productsapp.listen(PORT, () =&gt; &#123; console.log(`Gateway is running on http://localhost:$&#123;PORT&#125;`)&#125;) 共享資料庫 雖然在微服務架構中提倡每個服務都擁有自己的資料庫，但在某些情況下，服務間也可以通過共享資料庫的方式來達成資料通訊，但要注意資料的一致性與隔離性，避免產生緊耦合。 總結微服務雖然好處多多，但維護以及資料一致性上還是有些挑戰，對於擴展大型應用就很適合使用微服務，相對的，在開發小型專案或是初期階段，還是選擇單體式架構較容易些。也因此，在開發專案前可以事先考慮長遠因素，比如維護成本、系統的復雜度、以及團隊的技術能力等，再選擇適合的架構比較好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤歡迎指教，萬分感謝。 Referencehttps://ithelp.ithome.com.tw/articles/10228461"},{"title":"Bloom Filter 布隆過濾器","path":"/2024/02/05/BloomFilter/","content":"如何在上億筆使用者中檢查名稱是否存在前言在APP註冊時，有時會被提示使用者名稱已存在，這個功能該如何實現？比較直覺的方法是直接在資料庫中進行檢索，但資料量到達億級別時，這種方法肯定不可行，此篇會利用Redis內建布隆過濾器（Bloom Filter）資料結構實現 使用資料庫查詢1SELECT COUNT(*) FROM users WHERE username = ? 此方法會有以下缺點 在資料量大的情況，頻繁進行資料庫查詢，會造成效能下降、延遲，且查詢速度緩慢 資料庫負載高，每個查詢都會消耗資源，CPU和I&#x2F;O 資料存放於快取快取會佔用記憶體空間，直接將上億筆資料放入快取並非好的辦法 布隆過濾器(Bloom Filter)在此以查詢使用者名稱為例 過濾器核心思想如下 Bit Array ：一條大型元陣列，每個位置初始值為零，每個位置只會存放0或1，用來表示該元素（使用者名稱）是否存在。 Hash Functions：過濾器使用多個哈希函數，每個函數可以將輸入的使用者名稱映射到bit array的一個或多個位置。 使用上有兩種方法 新增元素 查詢元素 假設資料庫中有一億筆使用者，要先將所有使用者逐一添加至布隆過濾器，透過Hash Functions映射至bit array，當欲查詢使用者是否存在，會將使用者名稱透過Hash Functions映射至bit array相應位置，若該位置為1，代表存在，若為0代表不存在。 程式範例12345678910111213141516171819202122232425262728293031323334const Redis = require(&#x27;ioredis&#x27;);const redis = new Redis(); // 連接到 Redis 服務器async function setupBloomFilter() &#123; // 創建一個布隆過濾器，名為 &#x27;usersFilter&#x27;，預計插入量為 1000000000，錯誤率為 0.01 await redis.call(&#x27;BF.RESERVE&#x27;, &#x27;usersFilter&#x27;, 0.01, 1000000000); // 假設這是從 MySQL 數據庫中獲取的用戶名列表 const usernames = [&#x27;user1&#x27;, &#x27;user2&#x27;, &#x27;user3&#x27;]; // 將用戶名加入到布隆過濾器中 for (let username of usernames) &#123; await redis.call(&#x27;BF.ADD&#x27;, &#x27;usersFilter&#x27;, username); &#125;&#125;async function checkUserExists(username) &#123; // 檢查布隆過濾器中是否存在該用戶名 const exists = await redis.call(&#x27;BF.EXISTS&#x27;, &#x27;usersFilter&#x27;, username); if (exists) &#123; console.log(`用戶名 $&#123;username&#125; 可能存在。`); &#125; else &#123; console.log(`用戶名 $&#123;username&#125; 不存在。`); &#125;&#125;async function main() &#123; await setupBloomFilter(); // 設置布隆過濾器並添加用戶名 await checkUserExists(&#x27;user1&#x27;); // 檢查 &#x27;user1&#x27; 是否存在 await checkUserExists(&#x27;user4&#x27;); // 檢查 &#x27;user4&#x27; 是否存在 redis.quit();&#125;main(); 布隆過濾器優缺點優點 節省內存空間，不需直接將上億筆實際資料存放在快取，而是只存放透過hash functions轉換的哈希值。 高效率查詢，不用搜索整個資料庫，時間複雜度僅為O(1) 缺點 存在誤判率，有可能會誤判該元素已存在，但絕對不會誤判該元素不存在！因此不用擔心重名的問題 不能刪除元素，從集合中刪除元素會影響哈希值，增加誤判率 加入過濾器的耗時問題 將十億筆資料加入布隆過濾器的確可能會相當耗時，這取決於您的硬體資源、布隆過濾器的實現方式以及數據的加載速度。為了優化這一過程，可以考慮以下幾點： 批量處理：在加載數據到布隆過濾器時，可以採用批量處理的方式，以減少單次插入的開銷。 後台處理：可以在伺服器啟動後，利用後台任務進行數據的加載，以避免阻塞主要的服務流程。 分段加載：如果可能，可以將布隆過濾器的建立和更新過程分段進行，避免一次性處理所有數據。 資料庫有新增使用者的處理方式 對於資料庫中新增的使用者，確實需要將這些新使用者加入到布隆過濾器中，以保持布隆過濾器數據的最新性。這個過程可以通過以下方式進行： 即時更新：每當資料庫新增一個使用者時，同時將這個使用者名稱加入到布隆過濾器中。這要求系統能夠處理這些即時更新的操作。 定期更新：根據系統的實際需求和容錯率，可以選擇定期將新增的使用者名稱批量加入到布隆過濾器中。 欲刪除使用者的處理方式布隆過濾器不支持直接從集合中刪除使用者 1. 使用可計數的布隆過濾器（Counting Bloom Filter）可計數的布隆過濾器是布隆過濾器的一個變體，它不僅記錄某位是否被映射，而且記錄映射到該位的元素數量。這樣，當您需要“刪除”一個元素時，只需將該元素對應位上的計數減一。如果計數降至零，則相當於該位未被任何元素映射。但這種方法需要更多的空間來存儲計數信息。 2. 重建布隆過濾器當資料庫中刪除了一些元素後，您可以通過重新從資料庫中加載剩餘元素來重建布隆過濾器。雖然這個過程可能比較耗時，但它能夠確保布隆過濾器中的信息與資料庫保持一致。這種方法適用於元素刪除操作不頻繁的場景。 3. 使用其他數據結構輔助另一種策略是結合使用布隆過濾器和其他數據結構，例如哈希表。當布隆過濾器判斷一個元素可能存在時，可以進一步查詢哈希表來確定該元素是否真的存在。當元素被刪除時，只需要從哈希表中刪除該元素。這樣可以保持快速查詢的同時，也能夠處理元素的刪除操作。"}]