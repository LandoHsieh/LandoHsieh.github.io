[{"title":"如何提升API安全性","path":"/2024/02/27/API-security/","content":"前言API作為資料通訊的大門，我們應該重視它的安全性，即便有些API可以很輕鬆地去進行調用，但不代表應該讓所有API都不受限制地被存取調用。 API可以做很多事，資料請求、處理敏感資訊、CRUD資料庫，甚至可以透過API控制電子設備，因此在APP開發上，針對API做嚴格的身份驗證及管理就會顯得格外重要。 Authentication &amp; Authorization當收到API請求時，通常會先進行 Authentication以及Authorization 身份驗證以及授權，成功授權才可以進行請求， Authentication(驗證）: 顧名思義就是驗證使用者的身份是否正確，可透過username, password等方式進行驗證，這些資訊可在使用者的請求資訊中取得。 Authorization(授權)：當身份驗證成功，就能對進行授權，回傳資料給使用者。 1. 透過JWT實現授權JWT (Json Web Token)，通常在使用者成功登入後（驗證帳號密碼），會透過JWT產生一組具有時效性的Token給使用者（可儲存於cookies或localStorage），之後使用者在操作一些功能時必須將token一並附上才可使用。 生成JWT 程式範例 123456789101112131415161718const jwt = require(&#x27;jsonwebtoken&#x27;);// 用戶資訊，可以是任何你想要儲存在 token 中的資訊const user = &#123; id: 1, // 假設的用戶 ID username: &quot;exampleUser&quot;, email: &quot;user@example.com&quot;&#125;;// 密鑰，用於簽名 JWT，應保持秘密const secretKey = &quot;yourSecretKey&quot;;// 生成 JWTconst token = jwt.sign(user, secretKey, &#123; expiresIn: &#x27;1h&#x27; // token 有效期，這裡設為 1 小時&#125;);console.log(token); 當使用者欲發送API請求，需要將登入後拿到的token一併附上，server會透過此token進行驗證，並給予授權。 驗證JWT 程式範例 1234567891011121314151617181920212223// 替換成你的密鑰const secretKey = &quot;yourSecretKey&quot;;// JWT 驗證 Middlewareconst verifyToken = (req, res, next) =&gt; &#123; // 從請求頭部取得 token const token = req.headers[&#x27;authorization&#x27;]; if (!token) &#123; return res.status(403).send(&#123; message: &quot;未提供 token!&quot; &#125;); &#125; try &#123; // 驗證 token const decoded = jwt.verify(token, secretKey); // 將用戶資訊附加到請求對象 req.user = decoded; next(); &#125; catch (error) &#123; // 如果驗證失敗，返回錯誤訊息 return res.status(401).send(&#123; message: &quot;無效的 token!&quot; &#125;); &#125;&#125;; 2. 細粒度存取控制Fine-Grained Access Control定義角色和權限定義每個角色可以做什麼事情，像是Admin可以進入控制台介面，User則不行。 RBAC (Role-Based Access Control)RBAC是一種基於角色的訪問控制機制，每個角色都被授予一些權限，根據用戶的角色來決定對系統資源的訪問權限。在這種模式下，訪問權限會被賦予角色，用戶會被指派到一個或多個角色，這樣就能獲得相應的訪問權限。 1234567891011121314151617181920212223242526272829303132333435363738// 假設的用戶資料和角色const users = [ &#123; id: 1, username: &#x27;Lando&#x27;, role: &#x27;admin&#x27; &#125;, &#123; id: 2, username: &#x27;Josh&#x27;, role: &#x27;user&#x27; &#125;];// 簡單的身份驗證中間件function authMiddleware(req, res, next) &#123; const user = users.find(u =&gt; u.username === req.headers.username); // 假設使用username進行簡單的&quot;身份驗證&quot; if (!user) &#123; return res.status(401).send(&#x27;Authentication failed&#x27;); &#125; req.user = user; next();&#125;// 已定義好的角色權限const rolesPermissions = &#123; admin: [&#x27;create&#x27;, &#x27;read&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;], user: [&#x27;read&#x27;]&#125;;// RBAC中間件function roleMiddleware(allowedRoles) &#123; return function(req, res, next) &#123; const userRole = req.user.role; const permissions = rolesPermissions[userRole] || []; const isAllowed = allowedRoles.some(role =&gt; permissions.includes(role)); if (!isAllowed) &#123; return res.status(403).send(&#x27;Access denied&#x27;); &#125; next(); &#125;;&#125;app.get(&#x27;/data&#x27;, authMiddleware, roleMiddleware([&#x27;read&#x27;]), (req, res) =&gt; &#123; res.send(&#x27;Some data accessible by users with read permission&#x27;);&#125;); ABAC (Attribute-Based Access Control)ABAC能夠提供基於多種條件的細粒度訪問控制，當需要根據用戶的具體屬性（年齡、位置、工作角色等）來細化訪問權限，通常會使用於更複雜或是需要極度安全性的場景，例如軍事系統、政府等。 3. API Gateway提升安全性你可以把API網關想像成所有API的前門，所有請求都必須先通過前門才碰得到後面的API，舉個例子，假如每個API都有一樣的身份驗證middleware，這樣只需要在API gateway加入身份驗證，如此一來所有請求都會先進行身份驗證後，再將請求轉發到相應的API route。 API網關有以下用途： 增加安全性：防止未經授權的請求、濫用，或是DDoS攻擊。 Rate Limiting &#x2F; Throttling：速率控制和節流，防止API過度使用，或是確保使用者之間的公平使用，可使用express-rate-limit套件或是其他平台的服務，例如AWS API Gateway, Google Apigee等。 12345678910111213141516const rateLimit = require(&#x27;express-rate-limit&#x27;);// 創建 rate limit 中間件const limiter = rateLimit(&#123; windowMs: 15 * 60 * 1000, // 15 分鐘的時間窗口 max: 100, // 在時間窗口內每個IP可以發起的最大請求數 standardHeaders: true, // 返回 rate limit 信息於 `RateLimit-*` headers legacyHeaders: false, // 禁用 `X-RateLimit-*` headers message: &#x27;請求過於頻繁，請在一段時間後再試。&#x27; // 當 rate limit 被觸發時返回的錯誤信息&#125;);// 使用這個中間件於你的應用中，例如// app.use(limiter);// 你也可以只對特定的路由使用這個中間件// app.use(&#x27;/api/&#x27;, limiter); 資料驗證：驗證傳入的資料是否符合格式標準，亦可預防SQL Injection等攻擊。 透過SSL&#x2F;TLS加密傳輸資料到ZeroSSL網站為你的網域申請SSL憑證，申請成功會拿到certificate.crt以及private.key兩個憑證檔案，自行將其放入伺服器資料夾（我是放到 &#x2F;etc&#x2F;ssl 目錄底下 ），再透過nginx.conf設定SSL憑證路徑，保存後執行Nginx即可。 1234567891011121314server &#123; listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/your/certificate.crt; # Path to your fullchain.pem from CA ssl_certificate_key /path/to/your/private.key; # Path to your private key from CA # 指定TLS版本 ssl_protocols TLSv1.2 TLSv1.3; # 定義加密套件 ssl_ciphers &#x27;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256...&#x27;; # 其餘設定&#125; ssl_protocols : 指定TLS版本亦可提升安全性，在此指定1.2跟1.3版本的連線，因為這些是目前被認為是安全的協議版本，較舊的協議版本（如 SSL v2、SSL v3、TLS v1.0）因已知的安全漏洞而不建議使用。 ssl_ciphers : 這個指令用來定義哪些加密套件（cipher suites）被允許用於 SSL&#x2F;TLS 連線。加密套件定義了數據加密、驗證和消息完整性檢查的算法。 除了像SSL這種加密傳輸的方式以外，也有一些靜態加密的方法 bcrypt : 加密套件，在存入資料庫之前先對資料進加密。 MySQL : InnoDB表空間加密，在資料寫入磁碟前被加密，從磁碟讀取時解密。 MongoDB : 加密儲存引擎，也是在儲存資料之前先將其加密。 總結提升API的安全性除了能夠保障你的數位資產，同時也能夠保障用戶對你的信任，在開發API前不妨連同安全性也一起考慮進去，以防範各種網路威脅。"},{"title":"微服務 vs 單體式架構","path":"/2024/02/14/MicroservicesMonolithic/","content":"Microservices &amp; Monolithic Architecture前言我們以往都是透過單體式架構（Monolithic）去處理各種服務，且每個服務可能都依賴於同一個database，在部署上也只打包成一個名為”backend”的container，如下圖 但微服務不一樣的點在於，他是將每個服務獨立成自己的伺服器，以及配置他們專用的資料庫。 Microservices架構如下圖： 每個服務都有他們專屬的DB，而這些服務不需要都用同一種語言去編寫，可以是不同語言，最終只需要透過Protobuf去互相調用即可 Microservices vs Monolithic Architecture微服務架構（Microservices）與單體架構（Monolithic Architecture）的優缺點比較 特性 微服務架構 單體架構 開發複雜性 較高，需要管理多個服務的交互 較低，所有功能集中在一個應用中 技術棧靈活性 高，不同微服務可以使用不同的技術棧 低，整個應用通常使用單一技術棧 部署 獨立部署，單一服務的更新不會影響其他服務 整體部署，任何一個小改動都需要重新部署整個應用 擴展性 高，可以根據需求獨立擴展特定服務 低至中，擴展通常意味著擴展整個應用 容錯性 高，一個服務的失敗不會導致整個應用失敗 低，任何一個部分的失敗可能影響整個應用 開發和維護成本 較高，需要額外的管理和協調 較低，所有代碼在同一處管理 資料一致性 挑戰較大，需要管理跨服務的資料一致性 較容易實現，因為所有資料處理在同一應用內 啟動時間 快，單個微服務啟動時間短 慢，隨著應用規模增加，啟動時間可能變長 測試 複雜，需要考慮服務間的交互和集成測試 相對簡單，因為所有功能都在一個環境中 團隊協作 促進小團隊獨立工作，提高敏捷性 需要更大的團隊協作，可能導致溝通成本增加 各個服務間如何互相溝通？由於每個服務都是獨立的，那服務之間該如何互相溝通？假設一個電商網站中主要有Customer, Products, Shopping，三種獨立的服務，但Products需要依賴於Customer服務的資料，該怎麼辦？ 直接服務間調用： 同步調用： 在Products服務中透過HTTP、gRPC等通訊協議，直接對customer服務發送請求調用資料。 亦步調用： 使用消息隊列（如RabbitMQ、Kafka等）實現異步通訊，products服務發布消息到隊列，customer服務訂閱相應的消息進行處理，並將結果通過回調或再次發布消息的方式回傳。 這種方式適用於不需要即時響應的場景，能有效分散高峰流量。 API網關 (Gateway) 使用API gateway作為服務間的中介，所有外部請求都會先經過API gateway，並透過proxy將請求導向相應的服務。 當product服務需要customer服務的資料時，可以透過API gateway轉發請求。這種方式可以在 API 網關層面統一處理認證、授權、監控等跨服務的共通關切。 透過gateway管理請求，發送到不同服務 12345678910111213141516171819//API Gatewayconst express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)const proxy = require(&#x27;express-http-proxy&#x27;)const app = express()const PORT = 8000app.use(cors())app.use(express.json())app.use(&#x27;/customer&#x27;, proxy(&#x27;http://localhost:8001&#x27;))app.use(&#x27;/shopping&#x27;, proxy(&#x27;http://localhost:8003&#x27;))app.use(&#x27;/&#x27;, proxy(&#x27;http://localhost:8002&#x27;)) // productsapp.listen(PORT, () =&gt; &#123; console.log(`Gateway is running on http://localhost:$&#123;PORT&#125;`)&#125;) 共享資料庫 雖然在微服務架構中提倡每個服務都擁有自己的資料庫，但在某些情況下，服務間也可以通過共享資料庫的方式來達成資料通訊，但要注意資料的一致性與隔離性，避免產生緊耦合。 總結微服務雖然好處多多，但維護以及資料一致性上還是有些挑戰，對於擴展大型應用就很適合使用微服務，相對的，在開發小型專案或是初期階段，還是選擇單體式架構較容易些。也因此，在開發專案前可以事先考慮長遠因素，比如維護成本、系統的復雜度、以及團隊的技術能力等，再選擇適合的架構比較好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤歡迎指教，萬分感謝。 Referencehttps://ithelp.ithome.com.tw/articles/10228461"},{"title":"Bloom Filter 布隆過濾器","path":"/2024/02/05/BloomFilter/","content":"如何在上億筆使用者中檢查名稱是否存在前言在APP註冊時，有時會被提示使用者名稱已存在，這個功能該如何實現？比較直覺的方法是直接在資料庫中進行檢索，但資料量到達億級別時，這種方法肯定不可行，此篇會利用Redis內建布隆過濾器（Bloom Filter）資料結構實現 使用資料庫查詢1SELECT COUNT(*) FROM users WHERE username = ? 此方法會有以下缺點 在資料量大的情況，頻繁進行資料庫查詢，會造成效能下降、延遲，且查詢速度緩慢 資料庫負載高，每個查詢都會消耗資源，CPU和I&#x2F;O 資料存放於快取快取會佔用記憶體空間，直接將上億筆資料放入快取並非好的辦法 布隆過濾器(Bloom Filter)在此以查詢使用者名稱為例 過濾器核心思想如下 Bit Array ：一條大型元陣列，每個位置初始值為零，每個位置只會存放0或1，用來表示該元素（使用者名稱）是否存在。 Hash Functions：過濾器使用多個哈希函數，每個函數可以將輸入的使用者名稱映射到bit array的一個或多個位置。 使用上有兩種方法 新增元素 查詢元素 假設資料庫中有一億筆使用者，要先將所有使用者逐一添加至布隆過濾器，透過Hash Functions映射至bit array，當欲查詢使用者是否存在，會將使用者名稱透過Hash Functions映射至bit array相應位置，若該位置為1，代表存在，若為0代表不存在。 程式範例12345678910111213141516171819202122232425262728293031323334const Redis = require(&#x27;ioredis&#x27;);const redis = new Redis(); // 連接到 Redis 服務器async function setupBloomFilter() &#123; // 創建一個布隆過濾器，名為 &#x27;usersFilter&#x27;，預計插入量為 1000000000，錯誤率為 0.01 await redis.call(&#x27;BF.RESERVE&#x27;, &#x27;usersFilter&#x27;, 0.01, 1000000000); // 假設這是從 MySQL 數據庫中獲取的用戶名列表 const usernames = [&#x27;user1&#x27;, &#x27;user2&#x27;, &#x27;user3&#x27;]; // 將用戶名加入到布隆過濾器中 for (let username of usernames) &#123; await redis.call(&#x27;BF.ADD&#x27;, &#x27;usersFilter&#x27;, username); &#125;&#125;async function checkUserExists(username) &#123; // 檢查布隆過濾器中是否存在該用戶名 const exists = await redis.call(&#x27;BF.EXISTS&#x27;, &#x27;usersFilter&#x27;, username); if (exists) &#123; console.log(`用戶名 $&#123;username&#125; 可能存在。`); &#125; else &#123; console.log(`用戶名 $&#123;username&#125; 不存在。`); &#125;&#125;async function main() &#123; await setupBloomFilter(); // 設置布隆過濾器並添加用戶名 await checkUserExists(&#x27;user1&#x27;); // 檢查 &#x27;user1&#x27; 是否存在 await checkUserExists(&#x27;user4&#x27;); // 檢查 &#x27;user4&#x27; 是否存在 redis.quit();&#125;main(); 布隆過濾器優缺點優點 節省內存空間，不需直接將上億筆實際資料存放在快取，而是只存放透過hash functions轉換的哈希值。 高效率查詢，不用搜索整個資料庫，時間複雜度僅為O(1) 缺點 存在誤判率，有可能會誤判該元素已存在，但絕對不會誤判該元素不存在！因此不用擔心重名的問題 不能刪除元素，從集合中刪除元素會影響哈希值，增加誤判率 加入過濾器的耗時問題 將十億筆資料加入布隆過濾器的確可能會相當耗時，這取決於您的硬體資源、布隆過濾器的實現方式以及數據的加載速度。為了優化這一過程，可以考慮以下幾點： 批量處理：在加載數據到布隆過濾器時，可以採用批量處理的方式，以減少單次插入的開銷。 後台處理：可以在伺服器啟動後，利用後台任務進行數據的加載，以避免阻塞主要的服務流程。 分段加載：如果可能，可以將布隆過濾器的建立和更新過程分段進行，避免一次性處理所有數據。 資料庫有新增使用者的處理方式 對於資料庫中新增的使用者，確實需要將這些新使用者加入到布隆過濾器中，以保持布隆過濾器數據的最新性。這個過程可以通過以下方式進行： 即時更新：每當資料庫新增一個使用者時，同時將這個使用者名稱加入到布隆過濾器中。這要求系統能夠處理這些即時更新的操作。 定期更新：根據系統的實際需求和容錯率，可以選擇定期將新增的使用者名稱批量加入到布隆過濾器中。 欲刪除使用者的處理方式布隆過濾器不支持直接從集合中刪除使用者 1. 使用可計數的布隆過濾器（Counting Bloom Filter）可計數的布隆過濾器是布隆過濾器的一個變體，它不僅記錄某位是否被映射，而且記錄映射到該位的元素數量。這樣，當您需要“刪除”一個元素時，只需將該元素對應位上的計數減一。如果計數降至零，則相當於該位未被任何元素映射。但這種方法需要更多的空間來存儲計數信息。 2. 重建布隆過濾器當資料庫中刪除了一些元素後，您可以通過重新從資料庫中加載剩餘元素來重建布隆過濾器。雖然這個過程可能比較耗時，但它能夠確保布隆過濾器中的信息與資料庫保持一致。這種方法適用於元素刪除操作不頻繁的場景。 3. 使用其他數據結構輔助另一種策略是結合使用布隆過濾器和其他數據結構，例如哈希表。當布隆過濾器判斷一個元素可能存在時，可以進一步查詢哈希表來確定該元素是否真的存在。當元素被刪除時，只需要從哈希表中刪除該元素。這樣可以保持快速查詢的同時，也能夠處理元素的刪除操作。"}]