[{"title":"Flutter APK build release 問題筆記","path":"/2025/04/10/Flutter-release-build-note/","content":"最近在做 Flutter 專案，當我在 build release 版本的 Android 時，遇到一些瓶頸。以下是我遇到的問題以及如何解決的過程。 問題描述當我使用 flutter build apk --release 建置專案時，出現了很多錯誤 主要問題有以下兩類： 第一類：SDK 與 AGP 版本問題 SDK 版本不匹配：某些套件需要 Android SDK 35，但我的配置是 34。 當我升級 SDK 為 35 後，又出現 AGP 版本必須 ≥ 8.1.0 的問題 我透過 Android Studio 的 AGP Upgrade Assistant 來嘗試更新 AGP，卻沒看到 8.0.0 以上的版本 第二類：build release 會缺少一些必要 class 缺少必要的類：BouncyCastle 和 FindBugs 註解類缺失，導致建置失敗。 解決方法為了解決這些問題，我做了以下幾步： 我發現 Android Studio 因為版本過舊，所以才找不到 AGP8.0.0 以上的版本可以安裝，因此至官方下載最新版本 Android Studio 後，就能透過 AGP Upgrade Assistant 來幫你更新最新的 AGP version。 AGP 更新為 8.1.0 後，將 build.gradle 中的 compileSdk 和 targetSdkVersion 設置為 35，以滿足套件的需求。 添加 BouncyCastle 和 FindBugs 的依賴，以確保所有必要的類都存在。（下方詳細說明） 在 proguard-rules.pro 中添加規則，保留這些類，避免被 ProGuard 移除。（下方詳細說明） 透過 Android Studio 查看專案版本 在專案中對 android 右鍵，選擇 Open in Android Studio Android Studio 首次打開專案需要一點時間等他跑完，你可以先去滑個手機等等他 打開 File → Project Structure 就能看到相關版本資訊 SDK, AGP, Gradle plugin version 等等 添加 BouncyCastle 和 FindBugs 的依賴（以下步驟為如果在 build release 版本時有遇到關於 BouncyCastle 的問題才需要做。） 在 android/app/build.gradle 中 dependencies 的部分要加入以下依賴 123456dependencies &#123; implementation platform(&#x27;com.google.firebase:firebase-bom:33.12.0&#x27;) implementation &#x27;org.bouncycastle:bcprov-jdk15on:1.70&#x27; implementation &#x27;org.bouncycastle:bcpkix-jdk15on:1.70&#x27; implementation &#x27;com.google.code.findbugs:jsr305:3.0.2&#x27;&#125; 稍微解釋一下這幾個依賴的用途 BouncyCastle 相關依賴：12implementation &#x27;org.bouncycastle:bcprov-jdk15on:1.70&#x27;implementation &#x27;org.bouncycastle:bcpkix-jdk15on:1.70&#x27; BouncyCastle 是一個加密庫 bcprov 提供核心加密功能 bcpkix 提供 PKI&#x2F;X.509 相關功能， 這些是必須的，因為 MSAL 認證和 JWT 處理都需要這些加密功能 FindBugs 依賴：1implementation &#x27;com.google.code.findbugs:jsr305:3.0.2&#x27; 提供 @NonNull、@Nullable 等註解 MSAL 庫使用這些註解來標記參數的可空性 這個也是必須的，因為 MSAL 的程式碼依賴這些註解 proguard-rules.pro 添加規則關於 proguard-rules.pro，這個文件是 Android 專案的 ProGuard 配置文件，在 build release 版本時非常重要，特別是當我們啟用程式碼混淆（minification）的功能。 在 android/app/build.gradle 中，我們有寫到 1234567891011buildTypes &#123; release &#123; signingConfig signingConfigs.release // 使用程式碼混淆 minifyEnabled true // 刪除未使用資源 shrinkResources true // 添加proguard規則 proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; 從裡面可以看到，我們啟用 minifyEnabled 後，ProGuard 會幫我們刪除未使用的程式碼並進行混淆，用處是讓打包後的 APK 變得更小以及更安全，但這麼做有個缺點，因為有些類是通過反射或動態載入的，ProGuard 可能會誤判為未使用而移除，所以我們要添加 proguard-rules.pro 來告訴 ProGuard 哪些類必須保留，不能被移除或混淆。 在 android/app 底下加入 proguard-rules.pro 1234567891011# Keep BouncyCastle classes-keep class org.bouncycastle.** &#123; *; &#125;-dontwarn org.bouncycastle.**# Keep FindBugs annotations-keep class edu.umd.cs.findbugs.** &#123; *; &#125;-dontwarn edu.umd.cs.findbugs.**# Keep MSAL classes-keep class com.microsoft.identity.** &#123; *; &#125;-dontwarn com.microsoft.identity.** 那如果不啓用程式碼混淆是不是就不用加入 proguard-rules.pro？如果不起用 minifyEnabled，也不添加 proguard-rules.pro 的話，直接執行 flutter build apk --release ，還是會看到一堆可怕的訊息，如下圖： 這是因為，就算不啓用 minifyEnabled 和 shrinkResources，R8 也一樣會在 release 建置中運行，R8 是 ProGuard 的替代品，負責壓縮和優化程式碼。它會自動嘗試移除未使用的類和方法。 所以就算不起用 minifyEnabled，程式碼也是會受到 R8 自動刪除的影響，因此加入 proguard-rules.pro 是必要的 加入後，執行 flutter build apk —release 就成功嘍！ 結果經過這些修改後，release build 成功了！APK 大小減少，安全性提高，所有功能正常運行。 心得這次經驗讓我學到，release build 需要特別注意依賴和 ProGuard 規則的配置，這樣才能避免不必要的問題。","tags":["Flutter錯誤筆記"]},{"title":"Flutter 整合 MSAL(Microsoft Authentication Library) 筆記","path":"/2025/04/10/Flutter-Msal-note/","content":"這篇筆記會教你 Flutter 專案中整合 Microsoft Authentication Library (MSAL)，包含 iOS 和 Android 平台的完整設定步驟。 整合 MSAL 登入流程 (iOS)Azure Portal 新增 iOS 平台 到 Azure Portal 註冊你的 APP 管理 → 驗證，新增 iOS&#x2F;Android 平台 iOS 只需要把你的 APP Bundle ID 加入配套識別碼即可 Runner 設定 在你的專案中用 terminal 打開 Runner.xcworkspace，或輸入以下指令 1open ios/Runner.xcworkspace/ 添加一個 Keychain Sharing 的 Capability，並將 com.microsoft.adalcache 加入 Keychain Group 中 這麼做是因為，MSAL 登入後會將使用者的登入資訊存放在 Keychain iOS 的安全儲存系統中，儲存的內容包括如下 Access Token Refresh Token ID Token 使用者帳戶資訊 Token 的過期時間等 也因此，就算重新打開 APP，也會繼續顯示為登入狀態，如果要登出的話，就要呼叫signOut()動作，會自動清除 keychain 中的登入資訊。 清除的內容會有以下： 清除 Keychain 中儲存的所有認證資訊 移除快取的 token 清除當前登入的帳戶資訊 Info.plist 設定 （必要）加入 redirect URI scheme（這段是為了在你登入後將登入資訊回傳給你的 APP，一定要加） 123456789&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;msauth.$(PRODUCT_BUNDLE_IDENTIFIER)&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt; （可選）如果手機有安裝 Microsoft 的 Authenticator 這個 APP 的話，你希望在你 APP MSAL 登入時，都自動打開 Authenticator APP 來做登入，就要加入以下 Scheme，但若純粹指定使用 webview 來登入，就不需要（但也可以保留） 12345&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;string&gt;msauthv2&lt;/string&gt; &lt;string&gt;msauthv3&lt;/string&gt;&lt;/array&gt; 接下來就可以開始寫程式碼使用 MSAL 登入了 程式碼initial MSAL, iOS 的部分只需要寫入你的 Authority 參數即可通常為 “[https://login.microsoftonline.com/common](https://login.microsoftonline.com/common)” common：所有帳號都能存取organizations：只允許組織帳號存取xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx：特定組織帳號 1234567msalClient = await SingleAccountPca.create( appleConfig: AppleConfig( authority: dotenv.env[&#x27;AAD_APPLE_AUTHORITY&#x27;] ?? &#x27;&#x27;, authorityType: AuthorityType.aad, broker: Broker.webView, ), ); broker 的部分為選擇要跳出來的登入頁面是哪一種，這邊指定 webView 整合 MSAL 登入流程 (Android)Azure Portal 新增 Android 平台 跟 iOS 差不多，只是多新增一個 Android 的平台 套件名稱填入你的 Bundle ID 簽章雜湊用以下指令在你的 terminal 中執行，注意以下兩點 app/ 底下記得先產生好 release 用的 upload-keystore.jks 指令要在你的專案跟目錄中執行 1keytool -exportcert -alias androidreleasekey -keystore app/upload-keystore.jks | openssl sha1 -binary | openssl base64 建立 msal_config.json在你的專案中建立 msal_config.json （放哪裏都可以，我是放在assets/ 內，記得到pubspec.yaml 指定該資料夾，否則引用不到） 12345&#123; &quot;account_mode&quot;: &quot;SINGLE&quot;, &quot;broker_redirect_uri_registered&quot;: false, &quot;authorization_user_agent&quot;: &quot;BROWSER&quot;&#125; AndroidManifest.xml 添加依賴到 android/app/src/main/AndroidManifest.xml 添加以下 12345678910111213141516&lt;application&gt;... &lt;activity android:name=&quot;com.microsoft.identity.client.BrowserTabActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:host=&quot;這邊填入你的 Bundle ID&quot; android:path=&quot;/你剛用指令生成的簽章雜湊值&quot; android:scheme=&quot;msauth&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 程式碼 填入你的 Client ID 指定 msal_config.json 位置 填入 Redirect URI （用簽章雜湊產生的 URI） 1234567msalClient = await SingleAccountPca.create( clientId: dotenv.env[&#x27;AAD_CLIENT_ID&#x27;] ?? &#x27;&#x27;, androidConfig: AndroidConfig( configFilePath: &#x27;assets/msal_config.json&#x27;, redirectUri: dotenv.env[&#x27;AAD_ANDROID_REDIRECT_URI&#x27;] ?? &#x27;&#x27;, ), ); aad_oauth 以及 msal_auth 兩者套件差異？aad_oauth 用途：主要用於與 Azure Active Directory (AAD) 進行 OAuth 認證。 功能: 提供簡單的 OAuth2 認證流程，能夠獲取 access_token 和刷新 token。 適用場景: 適合需要與 Azure AD 整合的 App，特別是那些不需要複雜的身份驗證邏輯的應用。 msal_auth 用途: 基於 Microsoft Authentication Library (MSAL) 的身份驗證套件。 功能: 提供更全面的身份驗證功能，包括支援多組織帳戶、帳戶切換、token 緩存等。 適用場景: 適合需要更複雜的身份驗證邏輯的應用程序，特別是那些需要支持多組織帳戶或需要更高級的身份驗證功能的應用。 結論aad_oauth 用於 專案規模小 快速實現簡單認證 不需特別安全需求 原型開發或概念驗證 msal_auth 用於 需要企業級的安全性 需要支援 Microsoft Authenticator 需要處理複雜的認證場景 需要與 Microsoft 服務深度整合 長期維護的專案","tags":["Flutter"]},{"title":"📝 Flutter 錯誤筆記：Lexical or Preprocessor Issue (Include of non-modular header…)","path":"/2025/03/03/Xcode_Error_Lexical_or_Preprocessor_Issue/","content":"🔍 前言今天在執行 Flutter + Firebase 的專案時遇到一個問題，發生在 Xcode 15+ 版本。當執行 flutter run，Firebase 的 firebase_messaging 會報錯以下這則訊息： 1Lexical or Preprocessor Issue Include of non-modular header inside framework module &#x27;firebase_messaging&#x27;. 這導致整個專案無法成功編譯。 後來發現這個錯誤主要發生在 Xcode 更新後，影響了一些第三方套件（例如 Firebase）。避免以後發生同樣問題，為此整理了一篇筆記。 🤔 為什麼會發生這個錯誤？這與 Xcode 的模組化編譯規則 有關。Xcode 在較新的版本中，更嚴格地限制了 非模組化（Non-modular）Header 檔案 的引用方式。 在 Apple 的模組化編譯模式（Modular Build System）下，每個 Framework（或 Module）內部的 Header 應該被明確標記為 public 或 private，避免開發者直接使用內部 API。 但還是有一些 第三方套件（如 Firebase） 仍然包含了一些非模組化的 Header 檔案，而 Xcode 預設不允許這種方式，因此在 firebase_messaging 嘗試引用這些檔案時，編譯器會報錯。 ✅ 解決方案解法是修改 Xcode 的 Build Settings，允許專案使用 非模組化的 Header 檔案： 1️⃣ 打開 Xcode，開啟 Flutter 專案的 iOS 目錄 •\t執行 open ios&#x2F;Runner.xcworkspace（要用 xcworkspace 而不是 xcodeproj）。 2️⃣ 進入 Build Settings •\t在左側選擇 Runner，切換到 Build Settings。 •\t在搜尋框輸入 Allow Non-modular Includes In Framework Modules。 3️⃣ 將此設定改為 YES •\t預設情況下，這個選項是 NO，這代表 Xcode 會強制遵守模組化規則。 •\t設為 YES 後，Xcode 允許 在 Framework Modules 內部包含非模組化 Header，這樣 Firebase 就不會因為這個限制而報錯。 4️⃣ 重新執行 Flutter 專案 •\t執行 flutter clean 清除快取。 •\t執行 cd ios &amp;&amp; pod install 重新安裝 iOS 依賴。 •\t回到專案根目錄，執行 flutter run，應該就能順利編譯。 🎯 為什麼這樣能解決問題？設定 Allow Non-modular Includes In Framework Modules = YES 之後，Xcode 會允許 第三方套件（如 Firebase）引用未標記為模組化的 Header 檔案。 本質上，這個設定是放寬了 Xcode 的嚴格規則，讓專案可以繼續使用這些 非模組化的 Header 檔案，避免編譯時報錯。 不過這並非解決問題根本的方法，最好的方式還是 等待 Firebase 更新以適配新的 Xcode，或者手動調整 Firebase 的 module.modulemap 來明確標記 Header 的可見性（這需要修改 Firebase 套件的內部結構，風險較高）。 💡 建議1️⃣ 確保 Firebase SDK 是最新版本 •\t如果 Firebase 已經釋出針對 Xcode 15+ 的更新，應該優先更新，而不是長期依賴 Allow Non-modular Includes In Framework Modules = YES。 •\t更新方式： 12flutter pub upgrade firebase_messagingcd ios &amp;&amp; pod update 2️⃣ 避免直接修改 Xcode 設定，除非必要 •\t這個設定是 降低 Xcode 的編譯嚴格性，雖然能解決問題，但長遠來看，還是要讓專案符合 Apple 的模組化規範。 3️⃣ 如果遇到其他 Firebase 相關錯誤，可以試試這些步驟 •\tflutter clean •\trm -rf ios&#x2F;Pods ios&#x2F;Podfile.lock •\tcd ios &amp;&amp; pod install •\tflutter run 🏁 總結問題：Xcode 15+ 變更編譯規則，導致 Firebase 的 firebase_messaging 無法使用非模組化的 Header。 解法：在 Xcode Build Settings 設定 Allow Non-modular Includes In Framework Modules = YES，放寬 Xcode 的模組化限制。 建議： •\t長期來看，應該等待 Firebase 官方更新，避免直接修改 Xcode 設定。 •\t確保 Firebase SDK 維持最新版本，減少未來與 Xcode 的相容性問題。","tags":["Flutter錯誤筆記"]},{"title":"JWT是如何組成的","path":"/2024/08/16/HowJWTWork/","content":"JWT 結構JWT 是由三部分組成，並用 &quot;.&quot; 分隔： Header Payload Signature 1. Header 通常包含兩個屬性： alg: 簽名算法（例如 HMAC SHA256）。 typ: Token 的類型（通常為 “JWT”）。 內容以 JSON 格式表示，然後進行 Base64URL 編碼。 2. Payload 包含聲明（claims），分為三類： 註冊的聲明：預定義的屬性（像是 sub, iat, exp），提供關於 token 的一些基本資訊。 公共聲明：可以自行定義內容，像是 name, Email 等等。 私有聲明：依應用程序需求自定義的聲明。 同樣以 JSON 格式表示並進行 Base64URL 編碼。 3. Signature 用來驗證 token 的完整性和來源。 生成方法： 先將 header 和 payload 的編碼結果連接起來： &lt;encoded header&gt;.&lt;encoded payload&gt;。 將其與 secret key 結合，並使用指定的簽名算法進行 HMACSHA256 加密。 最後生成的 signature 格式為 Base64URL 編碼。 JWT 的組合最終生成的 JWT 格式為： &lt;encoded header&gt;.&lt;encoded payload&gt;.&lt;signature&gt; 注意事項 Base64URL 編碼 跟常規的 Base64 編碼 不一樣： JWT 主要使用 Base64URL 編碼 去做 encode 若用 一般 Base64 編碼 去產生 JWT，會導致無法驗正，因為 一般 Base64 包含了特殊字元 Base64 vs Base64URL 差異定義 Base64: 一種將二進位資料編碼成可傳輸的 ASCII 字符串的算法。 Base64URL: 這是基於 Base64 所衍生出來的，專門為 URL 跟網頁應用設計，主要是避免跟網頁 URL 中的特殊字符發生衝突。 主要差異 字符替換 Base64 使用以下字符： + 和 / Base64URL 使用以下字符： - 和 _ 填充字符 Base64 通常使用 = 作為填充字符。 Base64URL 省略了填充字符。"},{"title":"在iPhone上運行Flutter專案","path":"/2024/08/08/RunFlutterOnIOS/","content":"前言平常在 VS Code 上執行專案的方法不外乎就是先打開 IOS Simulator，然後再到 main.dart 中去 Start Debugging 快速啟動專案，那如果要在 iPhone 上運行專案，並且能夠 hot reload，該怎麼做？ 步驟 安裝 Xcode：確保你已經安裝了最新版本的 Xcode。 連接 iPhone：使用 USB 數據線將 iPhone 連接到你的 Mac。 打開 Xcode：在專案中打上 open ios/Runner.xcworkspace開啟 Xcode 確保達成以下條件 到 VS Code 左側欄 Flutter 的 Extenstion 內，選擇自己裝置 對 main.dart 按下 Start Debugging 此時，第一次執行手機上會出現未受信任開發者的提示到 設定 → 一般 → VPN 與裝置管理 → 信任開發者 信任後，重新執行專案，手機的 APP 就會正常啟動了！ 切換成另一個專案卻不能執行？假設第一個專案為的名稱為 ecommerce_shop，那預設的 Bundle Identifier 就會是com.example.ecommerceShop ，這時，你如果要切換成另一個專案，假設名為 todo_app ，這時他的預設 Bundle Identifier 會是 com.example.todoApp ，等於你的帳號底下有兩個com.example，這時就會出錯，如下圖 所以你要將 Bundle Identifier 改成唯一標識符，例如 com.landohsieh.todoApp 如下 然後再去執行一次專案，就能成功在手機上運作嘍！","tags":["Flutter"]},{"title":"如何在頁面導航時傳遞資料","path":"/2024/08/07/Flutter-ModalRoute/","content":"前言在 Flutter 中，當你從一個頁面導航到另一個頁面時，你可以傳遞資料給目標頁面。這可以通過 Navigator 和 ModalRoute 來實現。本文將介紹如何在頁面導航時傳遞資料，並展示具體的使用情境和程式碼範例。 使用情境假設你有一個應用程序，它會接收推送通知。當用戶點擊通知時，你希望導航到一個特定的頁面並顯示通知的內容。 步驟 設置導航路由：在 MaterialApp 中設置導航路由。 導航並傳遞資料：使用 Navigator.pushNamed 方法導航到目標頁面並傳遞資料。 接收資料：在目標頁面中使用 ModalRoute 來接收傳遞過來的資料。 程式碼範例1. 設置導航路由在 main.dart 中設置導航路由： 123456789101112131415161718192021222324252627282930313233import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:firebase_messaging/firebase_messaging.dart&#x27;;void main() &#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), routes: &#123; &#x27;/notification_screen&#x27;: (context) =&gt; const NotificationPage(), &#125;, ); &#125;&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;Home Page&quot;), ), body: Center( child: Text(&quot;Welcome to Home Page&quot;), ), ); &#125;&#125; 2. 導航並傳遞資料假設你在某個地方接收到推送通知，並希望導航到 NotificationPage： 12345678910111213141516final navigatorKey = GlobalKey&lt;NavigatorState&gt;();void handleMessage(RemoteMessage? message) &#123; if (message == null) return; navigatorKey.currentState?.pushNamed( &#x27;/notification_screen&#x27;, arguments: message, );&#125;Future initPushNotifications() async &#123; FirebaseMessaging.instance.getInitialMessage().then(handleMessage); FirebaseMessaging.onMessageOpenedApp.listen(handleMessage);&#125; 3. 接收資料在 NotificationPage 中使用 ModalRoute 來接收傳遞過來的資料： 1234567891011121314151617181920class NotificationPage extends StatelessWidget &#123; const NotificationPage(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; final message = ModalRoute.of(context)?.settings.arguments as RemoteMessage?; return Scaffold( appBar: AppBar( title: Text(&quot;Notification Page&quot;), ), body: Center( child: message != null ? Text(&quot;Message: $&#123;message.notification?.title ?? &#x27;No Title&#x27;&#125;&quot;) : Text(&quot;No message received&quot;), ), ); &#125;&#125; 總結 設置導航路由：在 MaterialApp 中設置導航路由，定義頁面路徑和對應的頁面小部件。 導航並傳遞資料：使用 Navigator.pushNamed 方法導航到目標頁面，並通過 arguments 傳遞資料。 接收資料：在目標頁面中使用 ModalRoute.of(context)?.settings.arguments 來接收傳遞過來的資料。 這樣，你就可以在頁面導航時傳遞資料，並在目標頁面中使用這些資料。","tags":["Flutter"]},{"title":"ECDH加密搭配JWT提升安全性","path":"/2024/08/05/JWT-ECDH/","content":"前言一般生成 JWT 時，都是透過設定好的固定字串當作 JWT 的密鑰（Secret key），然後再將 JWT 傳送到後端，並用相同的 Secret key 去做驗證，但這樣的做法安全性相對較低，如果固定的 Secret Key 被洩漏，攻擊者可以偽造 JWT，並且無法防止重放攻擊。 當使用 JWT（JSON Web Token）搭配 ECDH（橢圓曲線 Diffie-Hellman）密鑰交換來提升安全性時，主要目的是利用 ECDH 生成的共享秘密密鑰來簽名和驗證 JWT。這樣可以確保 JWT 的完整性和來源的可信性，並且在通信過程中不會暴露實際的簽名密鑰。 此篇將探討如何使用 ECDH 橢圓曲線進行密鑰交換生成 Secret Key 提升 JWT 的安全性。 使用情境假設有一個 IoT 設備（Device）需要對雲端服務（Server）發送 API 請求，請求中需要包含生成的 JTW，透過 JWT 驗證請求是否有效。以下是一個具體的使用情境： Device 初始化：第一次啟用 Device 時要做的事 Device 中生成一對 ECC 密鑰對（dPub和dPri），並將 dPub 傳送到後端 DB 儲存。（每個 Device 都有一個儲存自己 dPub 的欄位） Server 中生成一對 ECC 密鑰對（sPub和sPri），將 sPub 傳送給 Device 中儲存（亦可直接編譯在 Device 內） 這樣 Server 端就會有 dPub, sPub, sPri 三個，而 Device 內就會有 dPub, dPri, sPub 三個 當 Device 要對 Server 發送 API 請求時 Device 透過dPri跟sPub生成共享密鑰 (Secret Key) Device 用這個 Secret key 跟 Payload 簽名 JWT (payload 中包含 Device UUID) Device 將簽名好的 JWT 發送到 Server Server 收到 JWT 後，將 sPri與dPub生成共享密鑰 (Secret Key) Server 用這組密鑰驗證 JWT 是否有效，有效則處理 request 具體步驟與程式碼範例下面就用 ASP.NET 來做個範例，用於生成和驗證使用 ECDH 密鑰交換的 JWT： 1. 生成密鑰對123456789private static ECDsa _ecdsa;private static ECDsa _ecdsaByDevice;static JwtValidatorController()&#123; // 當Controller第一次被使用時生成ECDsa密鑰 _ecdsa = ECDsa.Create(ECCurve.NamedCurves.nistP256); _ecdsaByDevice = ECDsa.Create(ECCurve.NamedCurves.nistP256);&#125; 2. 生成 Server 端和 Device 端的公私鑰對123456789101112131415161718192021222324252627282930313233343536[HttpGet(&quot;generateKeyByServer&quot;)]public IActionResult GenerateKeys()&#123; byte[] publicKey = _ecdsa.ExportSubjectPublicKeyInfo(); string publicKeyBase64 = Convert.ToBase64String(publicKey); byte[] privateKey = _ecdsa.ExportPkcs8PrivateKey(); string privateKeyBase64 = Convert.ToBase64String(privateKey); var keys = new &#123; PublicKey = publicKeyBase64, PrivateKey = privateKeyBase64 &#125;; return Ok(keys);&#125;[HttpGet(&quot;generateKeyByDevice&quot;)]public IActionResult GenerateKeysByDevice()&#123; byte[] publicKey = _ecdsaByDevice.ExportSubjectPublicKeyInfo(); string publicKeyBase64 = Convert.ToBase64String(publicKey); byte[] privateKey = _ecdsaByDevice.ExportPkcs8PrivateKey(); string privateKeyBase64 = Convert.ToBase64String(privateKey); var keys = new &#123; PublicKey = publicKeyBase64, PrivateKey = privateKeyBase64 &#125;; return Ok(keys);&#125; 3. 創建 JWT123456789101112131415161718192021222324252627282930313233public class CreateJwtRequest&#123; public string ServerPublicKey &#123; get; set; &#125; public string DevciePrivateKey &#123; get; set; &#125;&#125;[HttpPost(&quot;create-jwt&quot;)]public IActionResult CreateJwt([FromBody] CreateJwtRequest request)&#123; var diffieHellmanA = ECDiffieHellman.Create(); diffieHellmanA.ImportSubjectPublicKeyInfo(Convert.FromBase64String(request.ServerPublicKey), out _); var diffieHellmanB = ECDiffieHellman.Create(); diffieHellmanB.ImportPkcs8PrivateKey(Convert.FromBase64String(request.DevciePrivateKey), out _); var derivedKey = diffieHellmanB.DeriveKeyMaterial(diffieHellmanA.PublicKey); var signingCredentials = new SigningCredentials(new SymmetricSecurityKey(derivedKey), SecurityAlgorithms.HmacSha256); var header = new JwtHeader(signingCredentials); var payload = new JwtPayload &#123; &#123; JwtRegisteredClaimNames.Sub, &quot;testuser&quot; &#125;, &#123; JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString() &#125;, &#123; &quot;exp&quot;, DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeSeconds() &#125; &#125;; var token = new JwtSecurityToken(header, payload); var tokenHandler = new JwtSecurityTokenHandler(); string jwt = tokenHandler.WriteToken(token); return Ok(new &#123; Token = jwt &#125;);&#125; 4. 驗證 JWT1234567891011121314151617181920212223242526272829303132333435363738394041public class VaildateJwtKey&#123; public string Jwt &#123; get; set; &#125; public string DevicePublicKey &#123; get; set; &#125; public string ServerPrivateKey &#123; get; set; &#125;&#125;[HttpPost(&quot;validate-jwt&quot;)]public IActionResult ValidateJwt([FromBody] VaildateJwtKey request)&#123; var tokenHandler = new JwtSecurityTokenHandler(); var jwtToken = tokenHandler.ReadJwtToken(request.Jwt); var diffieHellmanA = ECDiffieHellman.Create(); diffieHellmanA.ImportPkcs8PrivateKey(Convert.FromBase64String(request.ServerPrivateKey), out _); var diffieHellmanB = ECDiffieHellman.Create(); diffieHellmanB.ImportSubjectPublicKeyInfo(Convert.FromBase64String(request.DevicePublicKey), out _); var derivedKey = diffieHellmanA.DeriveKeyMaterial(diffieHellmanB.PublicKey); var validationParameters = new TokenValidationParameters &#123; ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, IssuerSigningKey = new SymmetricSecurityKey(derivedKey) &#125;; try &#123; var principal = tokenHandler.ValidateToken(request.Jwt, validationParameters, out var validatedToken); var claims = principal.Claims.Select(c =&gt; new &#123; c.Type, c.Value &#125;); return Ok(new &#123; Valid = true, Claims = claims &#125;); &#125; catch (Exception ex) &#123; return BadRequest(new &#123; Valid = false, Error = ex.Message &#125;); &#125;&#125; 這樣，你就可以使用 ECDH 密鑰交換來生成共享的秘密密鑰，並使用該密鑰來簽名和驗證 JWT，從而提升 JWT 的安全性。 ECDH 密鑰交換優缺點優點高安全性：◦ ECDH 密鑰交換協議確保只有通信雙方能生成相同的共享秘密密鑰，第三方無法獲取這個密鑰。◦ 每次通信都可以生成新的共享秘密密鑰，防止重放攻擊。 動態密鑰生成：◦ 每次通信都可以生成新的共享秘密密鑰，進一步提高安全性。 防篡改和偽造：◦ 由於密鑰交換過程中不傳輸私鑰，攻擊者無法偽造 JWT。 缺點實現複雜：◦ 需要實現 ECDH 密鑰交換協議，增加了實現的複雜性。◦ 需要管理公私鑰對，增加了開發和運維的負擔。 性能較低：◦ 生成和驗證 JWT 的過程中需要進行複雜的計算，性能較低。 總結使用 ECDH 密鑰交換來生成共享的秘密密鑰，並使用該秘密密鑰來簽名和驗證 JWT，具有以下優點： 提高安全性： ECDH 密鑰交換確保只有通信雙方能生成相同的共享秘密密鑰，第三方無法獲取這個密鑰。 使用共享的秘密密鑰來簽名和驗證 JWT，確保 JWT 的完整性和來源的可信性。 簡化密鑰管理： 雙方只需交換公鑰，無需共享私鑰，減少了密鑰管理的複雜性和風險。 動態密鑰生成： 每次通信都可以生成新的共享秘密密鑰，進一步提高安全性。","tags":["ASP.NET"]},{"title":"Flutter Riverpod 狀態管理工具","path":"/2024/07/24/Flutter-riverpod/","content":"什麼是 Riverpod？Riverpod 是由 Remi Rousselet 創建的一個強大且靈活的狀態管理解決方案。它旨在解決 Provider 包的一些限制，提供更好的可測試性、更多的靈活性和更少的全局狀態依賴。 安裝在你的 Flutter 項目中添加 flutter_riverpod 依賴項。 1234dependencies: flutter: sdk: flutter flutter_riverpod: ^1.0.0 然後運行以下命令來安裝依賴項： 1flutter pub get 基本用法1. 創建 ProviderProvider 是 Riverpod 中的核心概念，用於管理應用程序的狀態。以下是一個簡單的計數器 Provider： 123456import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateProviderfinal counterProvider = StateProvider&lt;int&gt;((ref) &#123; return 0;&#125;); 2. 使用 ProviderScopeProviderScope 是一個 Widget，用於提供一個狀態作用域，該作用域內的所有 Provider 都可以共享相同的狀態。通常將 ProviderScope 放在應用程序的根部。 123456789101112131415161718192021import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;void main() &#123; runApp( const ProviderScope( child: MyApp(), ), );&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), ); &#125;&#125; 3. 使用 ConsumerWidgetConsumerWidget 是一個 Widget，用於訪問和使用 Provider 的狀態。你可以在 build 方法中使用 ref.watch 來監聽 Provider 的狀態變化，並使用 ref.read 來更新狀態。 12345678910111213141516171819202122232425262728class HomePage extends ConsumerWidget &#123; @override Widget build(BuildContext context, WidgetRef ref) &#123; // 使用 Provider 來訪問狀態 final counter = ref.watch(counterProvider); return Scaffold( appBar: AppBar( title: Text(&#x27;Riverpod Example&#x27;), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(&#x27;Counter: $counter&#x27;), ElevatedButton( onPressed: () &#123; // 使用 Provider 來更新狀態 ref.read(counterProvider.state).state++; &#125;, child: Text(&#x27;Increment&#x27;), ), ], ), ), ); &#125;&#125; 進階用法1. 使用 StateNotifierProviderStateNotifierProvider 用於管理更複雜的狀態。你可以創建一個 StateNotifier 類來管理狀態，並使用 StateNotifierProvider 提供這個狀態。 12345678910111213import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateNotifier 類class CounterNotifier extends StateNotifier&lt;int&gt; &#123; CounterNotifier() : super(0); void increment() =&gt; state++;&#125;// 創建一個 StateNotifierProviderfinal counterNotifierProvider = StateNotifierProvider&lt;CounterNotifier, int&gt;((ref) &#123; return CounterNotifier();&#125;); 2. 使用 Provider 類型Riverpod 提供了多種 Provider 類型來管理不同的狀態： Provider：用於提供只讀的狀態。StateProvider：用於提供可變的狀態。FutureProvider：用於管理異步狀態。StreamProvider：用於管理流狀態。StateNotifierProvider：用於管理更複雜的狀態。 程式範例以下是一個完整的範例，展示如何使用 StateNotifierProvider 來管理計數器狀態： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;;// 創建一個 StateNotifier 類class CounterNotifier extends StateNotifier&lt;int&gt; &#123; CounterNotifier() : super(0); void increment() =&gt; state++;&#125;// 創建一個 StateNotifierProviderfinal counterNotifierProvider = StateNotifierProvider&lt;CounterNotifier, int&gt;((ref) &#123; return CounterNotifier();&#125;);void main() &#123; runApp( const ProviderScope( child: MyApp(), ), );&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), ); &#125;&#125;class HomePage extends ConsumerWidget &#123; @override Widget build(BuildContext context, WidgetRef ref) &#123; // 使用 Provider 來訪問狀態 final counter = ref.watch(counterNotifierProvider); return Scaffold( appBar: AppBar( title: Text(&#x27;Riverpod Example&#x27;), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(&#x27;Counter: $counter&#x27;), ElevatedButton( onPressed: () &#123; // 使用 Provider 來更新狀態 ref.read(counterNotifierProvider.notifier).increment(); &#125;, child: Text(&#x27;Increment&#x27;), ), ], ), ), ); &#125;&#125; 總結ProviderScope：提供一個狀態作用域，該作用域內的所有 Provider 都可以共享相同的狀態。Provider 類型：包括 Provider、StateProvider、FutureProvider、StreamProvider 和 StateNotifierProvider。","tags":["Flutter Package"]},{"title":"Dart中的const常量","path":"/2024/07/18/dart-const/","content":"什麼是 const在 Dart 和 Flutter 中，const關鍵字用於創建編譯時期常量。這意味著在編譯時期就確定了對象的值，並且在運行時期無法更改。 const 的優點1. 提升效能 使用 const 可以提升效能，因為常量對象在內存中只會創建一次，並且在多個地方重用。這減少了內存分配和垃圾回收的開銷。 2. 保證不可變性 const 保證對象在創建後無法更改，這有助於避免意外的狀態變更，並提高代碼的穩定性和可預測性。 使用 const 的注意事項1. 所有字段必須是 final 當你為一個類定義 const 構造函數時，該類中的所有字段必須是 final，因為 const 構造函數要求對象在編譯時期確定所有屬性。 123456789101112131415class MyButton extends StatelessWidget &#123; final String text; final VoidCallback onPressed; const MyButton(&#123; super.key, required this.text, required this.onPressed, &#125;); @override Widget build(BuildContext context) &#123; return const Placeholder(); &#125;&#125; 2. 嵌套的 const 如果一個 const 對象包含其他對象，這些對象也必須是 const。這樣可以確保整個對象樹在編譯時期都是常量。 12345const myList = [ const Text(&#x27;Item 1&#x27;), const Text(&#x27;Item 2&#x27;), const Text(&#x27;Item 3&#x27;),]; 3. 使用 const 構造函數 在 Flutter 中，許多 widget 可以使用 const 構造函數來創建不可變的 widget 樹。這有助於提高效能，因為常量 widget 不需要重新構建。 123456789101112@overrideWidget build(BuildContext context) &#123; return const Scaffold( appBar: AppBar( title: Text(&#x27;My App&#x27;), ), body: Center( child: Text(&#x27;Hello, World!&#x27;), ), );&#125; 4. 使用 const 關鍵字 在創建常量對象時，確保在構造函數前添加 const 關鍵字。這樣可以明確表示該對象是常量。 123456const myButton = MyButton( text: &#x27;Click Me&#x27;, onPressed: () &#123; print(&#x27;Button Pressed!&#x27;); &#125;,);","tags":["dart"]},{"title":"Future void vs void in Dart","path":"/2024/07/18/dart-future-void/","content":"Future vs void in Dart1. 概述在 Dart 中，Future&lt;void&gt; 和 void 都可以用來定義方法的返回類型，但它們有不同的用途和行為。理解這兩者的區別對於編寫清晰、可維護和正確的異步程式碼至關重要。 2. Future&lt;void&gt;定義Future&lt;void&gt; 表示一個異步操作，這個操作在完成時不會返回任何值。它允許調用者等待操作完成並進行錯誤處理。 使用情境當方法需要執行異步操作並且調用者需要等待操作完成時。當方法可能會拋出異步錯誤並且需要錯誤處理時。 範例1234567891011Future&lt;void&gt; fetchData() async &#123; // 模擬一個異步操作，例如網絡請求 await Future.delayed(Duration(seconds: 2)); print(&#x27;Data fetched&#x27;);&#125;void main() async &#123; print(&#x27;Fetching data...&#x27;); await fetchData(); print(&#x27;Data fetch complete&#x27;);&#125; 重點明確的異步操作：Future&lt;void&gt; 明確表示這是異步操作。等待異步操作完成：調用者可以使用 await 等待操作完成。錯誤處理：調用者可以使用 try-catch 進行錯誤處理。 3. void定義void 表示方法不會返回任何值。這通常用於同步方法，但也可以用於異步方法（不推薦）。 使用情境當方法是同步的並且不需要返回值時。當方法是異步的但調用者不需要等待操作完成（不推薦）。 範例1234567void printMessage() &#123; print(&#x27;Hello, World!&#x27;);&#125;void main() &#123; printMessage();&#125; 重點同步操作：通常用於同步方法。無法等待異步操作完成：如果用於異步方法，調用者無法等待操作完成，可能導致競態條件。 4. 比較 特性 Future&lt;void&gt; void 返回類型 異步操作，不返回值 同步操作，不返回值 等待操作完成 可以使用 await 等待操作完成 無法等待操作完成 錯誤處理 可以使用 try-catch 進行錯誤處理 只能處理同步錯誤 使用情境 當需要執行異步操作並等待完成時 當方法是同步且不需要返回值時 典型範例 網絡請求、文件操作等異步操作 打印消息、計算等同步操作 5. 總結Future&lt;void&gt;：適用於異步操作，允許調用者等待操作完成並進行錯誤處理。應該用於需要異步執行的任務。void：適用於同步操作，不允許調用者等待操作完成。應該用於不需要返回值的同步方法。","tags":["dart"]},{"title":"CAP定理-分散式系統","path":"/2024/03/25/CAP theorem/","content":"CAP主要是探討 資料分區 (Partition) 的問題，當為了分散流量處理而新增多個資料庫節點時，每個節點的資料勢必要保持一致，才不會導致有時使用者取得到的是最新資料，有時取得到舊資料，但世界上不存在100%穩定的網路，有時會因為延遲或斷線導致資料庫之間的資料不一致，這就是CAP主要探討的議題。 CAP定義CAP主要有以下三種條件 C 一致性 (Consistency)：使用者Always拿到最新的資料，所有分散式節點對同一份資料的讀取操作，都應該返回相同的值。 A 可用性 (Availability) : 使用者Always在有限時間內得到回應。 P 分區容錯性 (Partition tolerance) : 即使發生網路分區，系統也應該要能夠繼續運作。 CAP的選擇CAP定理告訴我們，在分散式系統中，不可能同時滿足ＣＡＰ三種條件，只能選擇其中兩種條件來滿足。 CA 一致性、可用性（最不考慮）不考慮CA是因為，若要滿足這兩個條件，必須確保各個節點的資料必須100%同步，且100％可用不出錯，這代表網路環境必須100%穩定才可實現，或是直接使用單一資料庫的架構（不必考慮資料庫間的網路問題），但這樣的做法就失去了CAP的意義，因此不考慮CA的組合。 CP 一致性、分區容錯性每個節點的讀寫都是最新的資料，也就是達成一致性，但又要在資料分區的狀況下讓系統正常運作，這意味著，必須犧牲掉可用性（Always取得回應），當資料分區時，我們沒辦法給予最新的資料，因此使用者的請求會直接失敗，沒有任何一個資料庫會片面地改變資料的狀態。 我們保證了資料的C（一致性），但犧牲了使用者總是能得到回應的A（可用性）。 AP 可用性、分區容錯性使用者Always得到回應，同時又要在資料分區狀況下讓系統正常運作，當使用者要新增資料到某個資料庫節點，但因為網路分區造成其他資料庫沒有即時同步，為了滿足Always得到回應，因此犧牲掉C (一致性) ，仍然將資料更新至該節點。 使用場合強一致性 (String Consistency)即為CP，對於一致性要求較高，可以容忍暫時不可用的應用，像是金融交易這類的，資料需要保持一致的場合。 最終一致性 (Eventually Consistency)即為AP，顧名思義就是“最後”才會保持一致，不必要求當下每個資料庫節點的資料就要立即一致，像是遇到網路暫時中斷或延遲，沒有即時同步資料到其他資料庫，還是可以讓使用者繼續存取資料得到回應（不是最新的資料也沒差），這種會應用在文章留言、影片觀看次數、社交媒體、內容轉發等場合。","tags":["分散式系統"]},{"title":"如何提升API安全性","path":"/2024/02/27/API-security/","content":"API作為資料通訊的大門，我們應該重視它的安全性，即便有些API可以很輕鬆地去進行調用，但不代表應該讓所有API都不受限制地被存取調用。 API可以做很多事，資料請求、處理敏感資訊、CRUD資料庫，甚至可以透過API控制電子設備，因此在APP開發上，針對API做嚴格的身份驗證及管理就會顯得格外重要。 Authentication &amp; Authorization當收到API請求時，通常會先進行 Authentication以及Authorization 身份驗證以及授權，成功授權才可以進行請求， Authentication(驗證）: 顧名思義就是驗證使用者的身份是否正確，可透過username, password等方式進行驗證，這些資訊可在使用者的請求資訊中取得。 Authorization(授權)：當身份驗證成功，就能對進行授權，回傳資料給使用者。 1. 透過JWT實現授權JWT (Json Web Token)，通常在使用者成功登入後（驗證帳號密碼），會透過JWT產生一組具有時效性的Token給使用者（可儲存於cookies或localStorage），之後使用者在操作一些功能時必須將token一並附上才可使用。 生成JWT 程式範例 123456789101112131415161718const jwt = require(&#x27;jsonwebtoken&#x27;);// 用戶資訊，可以是任何你想要儲存在 token 中的資訊const user = &#123; id: 1, // 假設的用戶 ID username: &quot;exampleUser&quot;, email: &quot;user@example.com&quot;&#125;;// 密鑰，用於簽名 JWT，應保持秘密const secretKey = &quot;yourSecretKey&quot;;// 生成 JWTconst token = jwt.sign(user, secretKey, &#123; expiresIn: &#x27;1h&#x27; // token 有效期，這裡設為 1 小時&#125;);console.log(token); 當使用者欲發送API請求，需要將登入後拿到的token一併附上，server會透過此token進行驗證，並給予授權。 驗證JWT 程式範例 1234567891011121314151617181920212223// 替換成你的密鑰const secretKey = &quot;yourSecretKey&quot;;// JWT 驗證 Middlewareconst verifyToken = (req, res, next) =&gt; &#123; // 從請求頭部取得 token const token = req.headers[&#x27;authorization&#x27;]; if (!token) &#123; return res.status(403).send(&#123; message: &quot;未提供 token!&quot; &#125;); &#125; try &#123; // 驗證 token const decoded = jwt.verify(token, secretKey); // 將用戶資訊附加到請求對象 req.user = decoded; next(); &#125; catch (error) &#123; // 如果驗證失敗，返回錯誤訊息 return res.status(401).send(&#123; message: &quot;無效的 token!&quot; &#125;); &#125;&#125;; 2. 細粒度存取控制Fine-Grained Access Control定義角色和權限定義每個角色可以做什麼事情，像是Admin可以進入控制台介面，User則不行。 RBAC (Role-Based Access Control)RBAC是一種基於角色的訪問控制機制，每個角色都被授予一些權限，根據用戶的角色來決定對系統資源的訪問權限。在這種模式下，訪問權限會被賦予角色，用戶會被指派到一個或多個角色，這樣就能獲得相應的訪問權限。 1234567891011121314151617181920212223242526272829303132333435363738// 假設的用戶資料和角色const users = [ &#123; id: 1, username: &#x27;Lando&#x27;, role: &#x27;admin&#x27; &#125;, &#123; id: 2, username: &#x27;Josh&#x27;, role: &#x27;user&#x27; &#125;];// 簡單的身份驗證中間件function authMiddleware(req, res, next) &#123; const user = users.find(u =&gt; u.username === req.headers.username); // 假設使用username進行簡單的&quot;身份驗證&quot; if (!user) &#123; return res.status(401).send(&#x27;Authentication failed&#x27;); &#125; req.user = user; next();&#125;// 已定義好的角色權限const rolesPermissions = &#123; admin: [&#x27;create&#x27;, &#x27;read&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;], user: [&#x27;read&#x27;]&#125;;// RBAC中間件function roleMiddleware(allowedRoles) &#123; return function(req, res, next) &#123; const userRole = req.user.role; const permissions = rolesPermissions[userRole] || []; const isAllowed = allowedRoles.some(role =&gt; permissions.includes(role)); if (!isAllowed) &#123; return res.status(403).send(&#x27;Access denied&#x27;); &#125; next(); &#125;;&#125;app.get(&#x27;/data&#x27;, authMiddleware, roleMiddleware([&#x27;read&#x27;]), (req, res) =&gt; &#123; res.send(&#x27;Some data accessible by users with read permission&#x27;);&#125;); ABAC (Attribute-Based Access Control)ABAC能夠提供基於多種條件的細粒度訪問控制，當需要根據用戶的具體屬性（年齡、位置、工作角色等）來細化訪問權限，通常會使用於更複雜或是需要極度安全性的場景，例如軍事系統、政府等。 3. API Gateway提升安全性你可以把API網關想像成所有API的前門，所有請求都必須先通過前門才碰得到後面的API，舉個例子，假如每個API都有一樣的身份驗證middleware，這樣只需要在API gateway加入身份驗證，如此一來所有請求都會先進行身份驗證後，再將請求轉發到相應的API route。 API網關有以下用途： 增加安全性：防止未經授權的請求、濫用，或是DDoS攻擊。 Rate Limiting &#x2F; Throttling：速率控制和節流，防止API過度使用，或是確保使用者之間的公平使用，可使用express-rate-limit套件或是其他平台的服務，例如AWS API Gateway, Google Apigee等。 12345678910111213141516const rateLimit = require(&#x27;express-rate-limit&#x27;);// 創建 rate limit 中間件const limiter = rateLimit(&#123; windowMs: 15 * 60 * 1000, // 15 分鐘的時間窗口 max: 100, // 在時間窗口內每個IP可以發起的最大請求數 standardHeaders: true, // 返回 rate limit 信息於 `RateLimit-*` headers legacyHeaders: false, // 禁用 `X-RateLimit-*` headers message: &#x27;請求過於頻繁，請在一段時間後再試。&#x27; // 當 rate limit 被觸發時返回的錯誤信息&#125;);// 使用這個中間件於你的應用中，例如// app.use(limiter);// 你也可以只對特定的路由使用這個中間件// app.use(&#x27;/api/&#x27;, limiter); 資料驗證：驗證傳入的資料是否符合格式標準，亦可預防SQL Injection等攻擊。 4. DOMPurify當我們設計一個Input的元件給客戶端做輸入時，也有機率遭受到攻擊，因為input可以被寫入程式碼，例如：&lt;script&gt;alert(false)&lt;/script&gt;，這時我們可以使用DOMPurify套件來清除輸入的資料，避免XSS攻擊。 安裝12345// 先執行命令進行安裝$ npm install dompurify// JS 檔案中 importimport * as DOMPurify from &#x27;dompurify&#x27;; 使用假如我們有一個input，取得使用者資訊 1&lt;input type=&quot;text&quot; id=&quot;userName&quot;&gt; 將資訊傳送給後端時先透過DOMPurify處理過 12const input = document.getElementById(&#x27;userName&#x27;);const userName = DOMPurify.sanitize(input.value); 這樣就可以清除程式碼的注入，多提升了一點安全性。 5. 透過SSL&#x2F;TLS加密傳輸資料到ZeroSSL網站為你的網域申請SSL憑證，申請成功會拿到certificate.crt以及private.key兩個憑證檔案，自行將其放入伺服器資料夾（我是放到 &#x2F;etc&#x2F;ssl 目錄底下 ），再透過nginx.conf設定SSL憑證路徑，保存後執行Nginx即可。 1234567891011121314server &#123; listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/your/certificate.crt; # Path to your fullchain.pem from CA ssl_certificate_key /path/to/your/private.key; # Path to your private key from CA # 指定TLS版本 ssl_protocols TLSv1.2 TLSv1.3; # 定義加密套件 ssl_ciphers &#x27;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256...&#x27;; # 其餘設定&#125; ssl_protocols : 指定TLS版本亦可提升安全性，在此指定1.2跟1.3版本的連線，因為這些是目前被認為是安全的協議版本，較舊的協議版本（如 SSL v2、SSL v3、TLS v1.0）因已知的安全漏洞而不建議使用。 ssl_ciphers : 這個指令用來定義哪些加密套件（cipher suites）被允許用於 SSL&#x2F;TLS 連線。加密套件定義了數據加密、驗證和消息完整性檢查的算法。 除了像SSL這種加密傳輸的方式以外，也有一些靜態加密的方法 bcrypt : 加密套件，在存入資料庫之前先對資料進加密。 MySQL : InnoDB表空間加密，在資料寫入磁碟前被加密，從磁碟讀取時解密。 MongoDB : 加密儲存引擎，也是在儲存資料之前先將其加密。 總結提升API的安全性除了能夠保障你的數位資產，同時也能夠保障用戶對你的信任，在開發API前不妨連同安全性也一起考慮進去，以防範各種網路威脅。"},{"title":"微服務 vs 單體式架構","path":"/2024/02/14/MicroservicesMonolithic/","content":"Microservices &amp; Monolithic Architecture前言我們以往都是透過單體式架構（Monolithic）去處理各種服務，且每個服務可能都依賴於同一個database，在部署上也只打包成一個名為”backend”的container，如下圖 但微服務不一樣的點在於，他是將每個服務獨立成自己的伺服器，以及配置他們專用的資料庫。 Microservices架構如下圖： 每個服務都有他們專屬的DB，而這些服務不需要都用同一種語言去編寫，可以是不同語言，最終只需要透過Protobuf去互相調用即可 Microservices vs Monolithic Architecture微服務架構（Microservices）與單體架構（Monolithic Architecture）的優缺點比較 特性 微服務架構 單體架構 開發複雜性 較高，需要管理多個服務的交互 較低，所有功能集中在一個應用中 技術棧靈活性 高，不同微服務可以使用不同的技術棧 低，整個應用通常使用單一技術棧 部署 獨立部署，單一服務的更新不會影響其他服務 整體部署，任何一個小改動都需要重新部署整個應用 擴展性 高，可以根據需求獨立擴展特定服務 低至中，擴展通常意味著擴展整個應用 容錯性 高，一個服務的失敗不會導致整個應用失敗 低，任何一個部分的失敗可能影響整個應用 開發和維護成本 較高，需要額外的管理和協調 較低，所有代碼在同一處管理 資料一致性 挑戰較大，需要管理跨服務的資料一致性 較容易實現，因為所有資料處理在同一應用內 啟動時間 快，單個微服務啟動時間短 慢，隨著應用規模增加，啟動時間可能變長 測試 複雜，需要考慮服務間的交互和集成測試 相對簡單，因為所有功能都在一個環境中 團隊協作 促進小團隊獨立工作，提高敏捷性 需要更大的團隊協作，可能導致溝通成本增加 各個服務間如何互相溝通？由於每個服務都是獨立的，那服務之間該如何互相溝通？假設一個電商網站中主要有Customer, Products, Shopping，三種獨立的服務，但Products需要依賴於Customer服務的資料，該怎麼辦？ 直接服務間調用： 同步調用： 在Products服務中透過HTTP、gRPC等通訊協議，直接對customer服務發送請求調用資料。 亦步調用： 使用消息隊列（如RabbitMQ、Kafka等）實現異步通訊，products服務發布消息到隊列，customer服務訂閱相應的消息進行處理，並將結果通過回調或再次發布消息的方式回傳。 這種方式適用於不需要即時響應的場景，能有效分散高峰流量。 API網關 (Gateway) 使用API gateway作為服務間的中介，所有外部請求都會先經過API gateway，並透過proxy將請求導向相應的服務。 當product服務需要customer服務的資料時，可以透過API gateway轉發請求。這種方式可以在 API 網關層面統一處理認證、授權、監控等跨服務的共通關切。 透過gateway管理請求，發送到不同服務 12345678910111213141516171819//API Gatewayconst express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)const proxy = require(&#x27;express-http-proxy&#x27;)const app = express()const PORT = 8000app.use(cors())app.use(express.json())app.use(&#x27;/customer&#x27;, proxy(&#x27;http://localhost:8001&#x27;))app.use(&#x27;/shopping&#x27;, proxy(&#x27;http://localhost:8003&#x27;))app.use(&#x27;/&#x27;, proxy(&#x27;http://localhost:8002&#x27;)) // productsapp.listen(PORT, () =&gt; &#123; console.log(`Gateway is running on http://localhost:$&#123;PORT&#125;`)&#125;) 共享資料庫 雖然在微服務架構中提倡每個服務都擁有自己的資料庫，但在某些情況下，服務間也可以通過共享資料庫的方式來達成資料通訊，但要注意資料的一致性與隔離性，避免產生緊耦合。 總結微服務雖然好處多多，但維護以及資料一致性上還是有些挑戰，對於擴展大型應用就很適合使用微服務，相對的，在開發小型專案或是初期階段，還是選擇單體式架構較容易些。也因此，在開發專案前可以事先考慮長遠因素，比如維護成本、系統的復雜度、以及團隊的技術能力等，再選擇適合的架構比較好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤歡迎指教，萬分感謝。 Referencehttps://ithelp.ithome.com.tw/articles/10228461"},{"title":"Bloom Filter 布隆過濾器","path":"/2024/02/05/BloomFilter/","content":"如何在上億筆使用者中檢查名稱是否存在前言在APP註冊時，有時會被提示使用者名稱已存在，這個功能該如何實現？比較直覺的方法是直接在資料庫中進行檢索，但資料量到達億級別時，這種方法肯定不可行，此篇會利用Redis內建布隆過濾器（Bloom Filter）資料結構實現 使用資料庫查詢1SELECT COUNT(*) FROM users WHERE username = ? 此方法會有以下缺點 在資料量大的情況，頻繁進行資料庫查詢，會造成效能下降、延遲，且查詢速度緩慢 資料庫負載高，每個查詢都會消耗資源，CPU和I&#x2F;O 資料存放於快取快取會佔用記憶體空間，直接將上億筆資料放入快取並非好的辦法 布隆過濾器(Bloom Filter)在此以查詢使用者名稱為例 過濾器核心思想如下 Bit Array ：一條大型元陣列，每個位置初始值為零，每個位置只會存放0或1，用來表示該元素（使用者名稱）是否存在。 Hash Functions：過濾器使用多個哈希函數，每個函數可以將輸入的使用者名稱映射到bit array的一個或多個位置。 使用上有兩種方法 新增元素 查詢元素 假設資料庫中有一億筆使用者，要先將所有使用者逐一添加至布隆過濾器，透過Hash Functions映射至bit array，當欲查詢使用者是否存在，會將使用者名稱透過Hash Functions映射至bit array相應位置，若該位置為1，代表存在，若為0代表不存在。 程式範例12345678910111213141516171819202122232425262728293031323334const Redis = require(&#x27;ioredis&#x27;);const redis = new Redis(); // 連接到 Redis 服務器async function setupBloomFilter() &#123; // 創建一個布隆過濾器，名為 &#x27;usersFilter&#x27;，預計插入量為 1000000000，錯誤率為 0.01 await redis.call(&#x27;BF.RESERVE&#x27;, &#x27;usersFilter&#x27;, 0.01, 1000000000); // 假設這是從 MySQL 數據庫中獲取的用戶名列表 const usernames = [&#x27;user1&#x27;, &#x27;user2&#x27;, &#x27;user3&#x27;]; // 將用戶名加入到布隆過濾器中 for (let username of usernames) &#123; await redis.call(&#x27;BF.ADD&#x27;, &#x27;usersFilter&#x27;, username); &#125;&#125;async function checkUserExists(username) &#123; // 檢查布隆過濾器中是否存在該用戶名 const exists = await redis.call(&#x27;BF.EXISTS&#x27;, &#x27;usersFilter&#x27;, username); if (exists) &#123; console.log(`用戶名 $&#123;username&#125; 可能存在。`); &#125; else &#123; console.log(`用戶名 $&#123;username&#125; 不存在。`); &#125;&#125;async function main() &#123; await setupBloomFilter(); // 設置布隆過濾器並添加用戶名 await checkUserExists(&#x27;user1&#x27;); // 檢查 &#x27;user1&#x27; 是否存在 await checkUserExists(&#x27;user4&#x27;); // 檢查 &#x27;user4&#x27; 是否存在 redis.quit();&#125;main(); 布隆過濾器優缺點優點 節省內存空間，不需直接將上億筆實際資料存放在快取，而是只存放透過hash functions轉換的哈希值。 高效率查詢，不用搜索整個資料庫，時間複雜度僅為O(1) 缺點 存在誤判率，有可能會誤判該元素已存在，但絕對不會誤判該元素不存在！因此不用擔心重名的問題 不能刪除元素，從集合中刪除元素會影響哈希值，增加誤判率 加入過濾器的耗時問題 將十億筆資料加入布隆過濾器的確可能會相當耗時，這取決於您的硬體資源、布隆過濾器的實現方式以及數據的加載速度。為了優化這一過程，可以考慮以下幾點： 批量處理：在加載數據到布隆過濾器時，可以採用批量處理的方式，以減少單次插入的開銷。 後台處理：可以在伺服器啟動後，利用後台任務進行數據的加載，以避免阻塞主要的服務流程。 分段加載：如果可能，可以將布隆過濾器的建立和更新過程分段進行，避免一次性處理所有數據。 資料庫有新增使用者的處理方式 對於資料庫中新增的使用者，確實需要將這些新使用者加入到布隆過濾器中，以保持布隆過濾器數據的最新性。這個過程可以通過以下方式進行： 即時更新：每當資料庫新增一個使用者時，同時將這個使用者名稱加入到布隆過濾器中。這要求系統能夠處理這些即時更新的操作。 定期更新：根據系統的實際需求和容錯率，可以選擇定期將新增的使用者名稱批量加入到布隆過濾器中。 欲刪除使用者的處理方式布隆過濾器不支持直接從集合中刪除使用者 1. 使用可計數的布隆過濾器（Counting Bloom Filter）可計數的布隆過濾器是布隆過濾器的一個變體，它不僅記錄某位是否被映射，而且記錄映射到該位的元素數量。這樣，當您需要“刪除”一個元素時，只需將該元素對應位上的計數減一。如果計數降至零，則相當於該位未被任何元素映射。但這種方法需要更多的空間來存儲計數信息。 2. 重建布隆過濾器當資料庫中刪除了一些元素後，您可以通過重新從資料庫中加載剩餘元素來重建布隆過濾器。雖然這個過程可能比較耗時，但它能夠確保布隆過濾器中的信息與資料庫保持一致。這種方法適用於元素刪除操作不頻繁的場景。 3. 使用其他數據結構輔助另一種策略是結合使用布隆過濾器和其他數據結構，例如哈希表。當布隆過濾器判斷一個元素可能存在時，可以進一步查詢哈希表來確定該元素是否真的存在。當元素被刪除時，只需要從哈希表中刪除該元素。這樣可以保持快速查詢的同時，也能夠處理元素的刪除操作。"}]